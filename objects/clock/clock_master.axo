<objdefs appVersion="1.0.12">
   <obj.normal id="clock_master" uuid="5224773f-18de-4231-8f92-b1f22bb953B4">
      <sDescription>Unified clock: sync_clock_musical + tap tempo + external MIDI clock. RBRT sync inlets/outlets; tap and countIn for tap tempo; clockMode for Auto/Ext/Int. Modes: 0=Auto (switch to external when available), 1=Ext (external only), 2=Int (internal only). Receives MIDI clock/start/stop; dropout detection ~250ms. MIDI START always restarts clock and sends reset pulse. extSync outlet indicates external sync status. When syncing to external, tap tempo and BPM inlet are disabled.</sDescription>
      <author>Simon Reeve</author>
      <license>GPL</license>
      <inlets>
         <int32.positive name="toSlot"/>
         <bool32.rising name="setNow"/>
         <bool32.rising name="inSync"/>
         <bool32 name="setToRaw"/>
         <bool32.rising name="resetPhase"/>
         <int32.positive name="quantization"/>
         <bool32 name="NOrecalc"/>
         <bool32 name="NOquantize"/>
         <bool32 name="skipRaw"/>
         <bool32 name="EXTsync"/>
         <frac32.positive name="EXTphase"/>
         <int32.positive name="EXTdurSMPS"/>
         <bool32.rising name="play"/>
         <bool32.rising name="stop"/>
         <bool32.rising name="playToggle"/>
         <int32 name="beats"/>
         <int32 name="measure"/>
         <int32 name="lowerBPM"/>
         <bool32.rising name="setBPM"/>
         <int32 name="bpmValue"/>
         <bool32.rising name="tap" description="Tap tempo input"/>
         <bool32 name="countIn" description="Count-in: first bar then next tap starts clock"/>
         <int32 name="clockMode" description="0=Auto, 1=Ext, 2=Int"/>
      </inlets>
      <outlets>
         <int32.positive name="syncSlot"/>
         <frac32.positive name="syncPhase"/>
         <int32.positive name="syncDurSMPS"/>
         <bool32.pulse name="rollover"/>
         <bool32.pulse name="clock24ppq"/>
         <bool32.pulse name="reset"/>
         <bool32 name="isPlaying"/>
         <int32 name="bpm"/>
         <int32 name="detectedBars"/>
         <int32 name="ppqPerBar"/>
         <bool32 name="extSync" description="High when syncing to external MIDI clock"/>
         <int32 name="v004" description="Object version v001=1 v002=2 v003=3 v004=4 etc"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <combo name="setTempoTo">
            <MenuEntries>
               <string>cycles</string>
               <string>raw</string>
            </MenuEntries>
            <CEntries>
               <string>0</string>
               <string>1</string>
            </CEntries>
         </combo>
         <spinner name="bpmPage" description="Page index for BPM storage" MinValue="0" MaxValue="63" DefaultValue="8"/>
         <spinner name="bpmParam" description="Parameter index for BPM storage (0-7)" MinValue="0" MaxValue="7" DefaultValue="4"/>
         <combo name="quantization">
            <MenuEntries>
               <string>auto</string>
               <string>1/1</string>
               <string>1/2</string>
               <string>1/4</string>
               <string>1/8</string>
               <string>1/16</string>
               <string>1/32</string>
            </MenuEntries>
            <CEntries>
               <string>0</string>
               <string>1</string>
               <string>2</string>
               <string>4</string>
               <string>8</string>
               <string>16</string>
               <string>32</string>
            </CEntries>
         </combo>
         <spinner name="defaultBeats" MinValue="1" MaxValue="16" DefaultValue="4"/>
         <spinner name="defaultMeasure" MinValue="1" MaxValue="16" DefaultValue="4"/>
         <spinner name="defaultLowerBPM" MinValue="40" MaxValue="180" DefaultValue="90"/>
      </attribs>
      <includes>
         <include>../../../Axolonatics/objects/rbrt_new/rbrt_classes/Smplr.h</include>
         <include>../../../Axolonatics/objects/rbrt_new/rbrt_classes/sync.h</include>
      </includes>
      <code.declaration><![CDATA[Smplr smplr;
SYNC sync;
bool rtrig;
bool strig;
bool wait;
bool ro;
uint32_t pos;
uint8_t count;
float frac;
uint32_t old_tempo;
uint32_t rosl;
uint16_t waitadr;
uint32_t roext;

uint8_t resync;
bool presrc;

// Direct param table access for BPM
rootc::objectinstance_sketchy__params* param_table;
int32_t last_written_bpm;  // Track last BPM written to prevent unnecessary writes

bool clock_playing;
bool play_trig, stop_trig, play_toggle_trig;
int8_t prev_leader;

uint32_t prev_clock_pos;
uint8_t clock_count;

int32_t current_bpm;
int32_t detected_bars;
uint8_t current_beats;
uint8_t current_measure;
uint8_t current_lower_bpm;
uint16_t ppq_per_bar;
bool setBPM_trig;

// Tap tempo state (fused from tap_tempo_musical)
int32_t tap_timer;
const int tap_pool_size = 16;
int32_t tap_pool[16];
int tap_pool_index;
bool tap_last_inlet;
const int tap_wait_samples = 96000;
bool tap_active;
int32_t tap_avg;
int32_t tap_last_out_bpm;
int32_t tap_last_inlet_bpm;
int32_t tap_bpm;
int tap_count_phase;
int tap_start_hold;
int tap_reset_hold;

// Effective inlets after tap (tap can drive setBPM/reset/play)
int32_t eff_bpmValue;
bool eff_setBPM;
bool eff_resetPhase;
bool eff_play;

// External MIDI clock handling (from tap.io)
int isClockIncoming;        // Flag for external clock presence
int16_t midi_timer;         // Timer for clock dropout detection
int shouldTrigger24Ppq_ext; // External clock pulse trigger
const int clockDropoutSamples = 12000; // ~250ms at 48kHz
bool midiStartReceived;     // Track MIDI START message
bool midiStopReceived;      // Track MIDI STOP message
int midi_start_reset_hold;  // Hold reset pulse for MIDI START

// Clock mode state
int current_clock_mode;     // 0=Auto, 1=Ext, 2=Int

// External clock timing measurement
const int ext_clock_avg_steps = 96;
int16_t ext_clock_pool[96];
int ext_clock_pool_index;
float ext_clock_avg;

// Measure external MIDI clock timing (called on each MIDI_TIMING_CLOCK)
void measureExternalClock() {
    isClockIncoming = true;
    
    // Record the time since last clock pulse
    ext_clock_pool[ext_clock_pool_index] = midi_timer;
    midi_timer = 0; // Reset timer for next pulse
    ext_clock_pool_index++;
    if (ext_clock_pool_index >= ext_clock_avg_steps) ext_clock_pool_index = 0;
    
    // Calculate average interval over last 96 pulses
    float sum = 0;
    for (int i = 0; i < ext_clock_avg_steps; i++) {
        sum += ext_clock_pool[i];
    }
    ext_clock_avg = sum / ext_clock_avg_steps;
    
    // Calculate BPM from average (24ppq means 24 pulses = 1 quarter note)
    // BPM = (60 * sample_rate) / (samples_per_quarter_note)
    // samples_per_quarter_note = ext_clock_avg * 24
    if (ext_clock_avg > 0) {
        float samples_per_qn = ext_clock_avg * 24.0;
        int32_t ext_bpm = (int32_t)((60.0 * 48000.0) / samples_per_qn + 0.5);
        if (ext_bpm >= 40 && ext_bpm <= 300) {
            current_bpm = ext_bpm; // Update BPM from external clock
            
            // Write to param table immediately so display updates (MIDI handler runs async, so do it here)
            param_table->array[attr_bpmPage][attr_bpmParam] = ext_bpm;
            last_written_bpm = ext_bpm;
            
            // Also update internal tempo so when ext clock drops out, 
            // Auto mode can continue at same tempo
            if (detected_bars > 0 && current_beats > 0 && current_measure > 0) {
                smplr.leader_tempo = bpmToTempo(ext_bpm, detected_bars, current_beats, current_measure);
            }
        }
    }
    
    shouldTrigger24Ppq_ext = true;
}

// Musical helpers (from sync_clock_musical)
int32_t interpretLoopLength(uint32_t loop_samples, int32_t lower_bpm, int32_t beats, int32_t measure) {
    float quarter_note_duration = 60.0 / (float)lower_bpm;
    uint32_t samples_per_bar = (uint32_t)(quarter_note_duration * 48000.0 * (float)beats / ((float)measure / 4.0));
    float calculated_bars = (float)loop_samples / (float)samples_per_bar;
    int valid_bars_x16[] = {1, 2, 4, 8, 16, 32, 64, 128, 256};
    int closest_bars_x16 = 16;
    for (int i = 0; i < 9; i++) {
        if ((calculated_bars * 16.0) <= (float)valid_bars_x16[i]) {
            closest_bars_x16 = valid_bars_x16[i];
            break;
        }
    }
    if (calculated_bars > 16.0) closest_bars_x16 = 256;
    return closest_bars_x16;
}

int32_t calculateBPM(uint32_t tempo_samples, int32_t bars_x16, int32_t beats, int32_t measure) {
    if (tempo_samples == 0 || bars_x16 == 0) return 120;
    float actual_bars = (float)bars_x16 / 16.0;
    float samples_per_bar = (float)tempo_samples / actual_bars;
    float quarter_notes_per_bar = (float)beats / ((float)measure / 4.0);
    float bpm = (60.0 * 48000.0 * quarter_notes_per_bar) / samples_per_bar;
    return (int32_t)(bpm + 0.5);
}

uint32_t bpmToTempo(int32_t bpm, int32_t bars_x16, int32_t beats, int32_t measure) {
    if (bpm == 0) return 48000 * 2;
    float actual_bars = (float)bars_x16 / 16.0;
    float quarter_notes_per_bar = (float)beats / ((float)measure / 4.0);
    float samples_per_bar = (60.0 * 48000.0 * quarter_notes_per_bar) / (float)bpm;
    return (uint32_t)(samples_per_bar * actual_bars);
}

uint32_t scale_tempo_musical(uint32_t raw_samples, int32_t lower_bpm, int32_t beats, int32_t measure, int32_t* out_bars) {
    *out_bars = interpretLoopLength(raw_samples, lower_bpm, beats, measure);
    float calculated_bpm = (float)calculateBPM(raw_samples, *out_bars, beats, measure);
    float upper_bpm = (float)lower_bpm * 2.0;
    while (calculated_bpm >= upper_bpm && *out_bars > 1) {
        *out_bars /= 2;
        calculated_bpm = (float)calculateBPM(raw_samples, *out_bars, beats, measure);
    }
    while (calculated_bpm < (float)lower_bpm && *out_bars < 256) {
        *out_bars *= 2;
        calculated_bpm = (float)calculateBPM(raw_samples, *out_bars, beats, measure);
    }
    return raw_samples;
}]]></code.declaration>
      <code.init><![CDATA[current_bpm = 120;
detected_bars = 16;
current_beats = attr_defaultBeats;
current_measure = attr_defaultMeasure;
current_lower_bpm = attr_defaultLowerBPM;
ppq_per_bar = 96;
setBPM_trig = false;

clock_playing = 0;  // No clock by default; start via record leader, tap count-in, or play
prev_leader = -1;

// Initialize param table access
param_table = &parent->objectinstance_sketchy__params_i;
last_written_bpm = -1;  // Force initial write

// Read initial BPM from param table if available
int32_t initial_bpm = param_table->array[attr_bpmPage][attr_bpmParam];
if (initial_bpm > 0 && initial_bpm >= 40 && initial_bpm <= 300) {
    tap_bpm = initial_bpm;
    current_bpm = initial_bpm;
}

tap_timer = tap_wait_samples;
tap_last_inlet = false;
tap_active = false;
tap_avg = 24000;
tap_pool_index = 0;
tap_last_out_bpm = 0;
tap_last_inlet_bpm = 0;
tap_bpm = 120;
tap_count_phase = 0;
tap_start_hold = 0;
tap_reset_hold = 0;
for (int i = 0; i < tap_pool_size; i++) {
    tap_pool[i] = 0;
}

// External MIDI clock state
isClockIncoming = false;
midi_timer = 0;
shouldTrigger24Ppq_ext = false;
midiStartReceived = false;
midiStopReceived = false;
midi_start_reset_hold = 0;
current_clock_mode = 0; // Default to Auto
ext_clock_pool_index = 0;
ext_clock_avg = 1000.0; // Default interval for 120 BPM (1000 samples @ 48kHz, 24ppq)
for (int i = 0; i < ext_clock_avg_steps; i++) {
    ext_clock_pool[i] = 1000; // Initialize to 120 BPM timing
}]]></code.init>
      <code.krate><![CDATA[bool trig = 0;
bool ttrig = 0;
ro = 0;
outlet_reset = 0;

uint16_t adr = inlet_toSlot * 128;

// Update clock mode from inlet
current_clock_mode = inlet_clockMode;
if (current_clock_mode < 0) current_clock_mode = 0;
if (current_clock_mode > 2) current_clock_mode = 2;

// Handle MIDI START reset pulse
if (midi_start_reset_hold > 0) {
    outlet_reset = 1;
    midi_start_reset_hold--;
}

// Determine if using external sync (actually receiving and using external clock)
bool use_external = (current_clock_mode == 1 && isClockIncoming) || // Ext mode WITH clock
                    (current_clock_mode == 0 && isClockIncoming); // Auto + clock present

// Set extSync outlet
outlet_extSync = use_external;

// --- Tap tempo block: run first, use clock_playing as isPlaying ---
// Read BPM directly from param table, fallback to inlet for backward compatibility
int32_t param_bpm = param_table->array[attr_bpmPage][attr_bpmParam];
int32_t inlet_bpm = (inlet_bpmValue > 0) ? inlet_bpmValue : param_bpm;  // Use param table as primary source

// Skip tap tempo and BPM inlet when syncing to external clock
int tap_beats = (inlet_beats > 0 && inlet_beats <= 16) ? inlet_beats : 4;
bool in_tap_window = (tap_timer < tap_wait_samples);

bool bpm_changed = false;
bool bpm_from_inlet = false;

if (!use_external && inlet_bpm > 0 && inlet_bpm != tap_last_inlet_bpm) {
    // Only treat as feedback when reading from external inlet; when reading from param table (encoder) allow updates
    bool reading_from_inlet = (inlet_bpmValue > 0);
    bool is_feedback = reading_from_inlet && ((inlet_bpm == tap_bpm) || (inlet_bpm == current_bpm));
    if (!is_feedback) {
        tap_bpm = inlet_bpm;
        if (tap_bpm < 40) tap_bpm = 40;
        if (tap_bpm > 300) tap_bpm = 300;
        bpm_changed = true;
        for (int i = 0; i < tap_beats; i++) tap_pool[i] = 0;
        tap_pool_index = 0;
        tap_active = false;
    }
    tap_last_inlet_bpm = inlet_bpm;
    bpm_from_inlet = !is_feedback;
} else if (!use_external && inlet_bpm > 0 && !in_tap_window) {
    // Encoder/param table update: sync tap_bpm and trigger clock update when value actually changed
    if (inlet_bpm != tap_bpm) {
        tap_bpm = inlet_bpm;
        if (tap_bpm < 40) tap_bpm = 40;
        if (tap_bpm > 300) tap_bpm = 300;
        bpm_changed = true;
    }
    tap_last_inlet_bpm = inlet_bpm;
    bpm_from_inlet = true;
} else if (inlet_bpm > 0) {
    tap_last_inlet_bpm = inlet_bpm;
    bpm_from_inlet = false;
} else {
    tap_last_inlet_bpm = 0;
    bpm_from_inlet = false;
}

bool tap_rising = (!use_external && inlet_tap) && !tap_last_inlet;
tap_last_inlet = inlet_tap;

if (!inlet_countIn) tap_count_phase = 0;

eff_setBPM = false;
eff_resetPhase = (tap_reset_hold > 0);
eff_play = (tap_start_hold > 0);
if (tap_reset_hold > 0) tap_reset_hold--;
if (tap_start_hold > 0) tap_start_hold--;

if (tap_rising) {
    if (tap_timer >= tap_wait_samples) {
        for (int i = 0; i < tap_beats; i++) tap_pool[i] = 0;
        tap_pool_index = 0;
        tap_count_phase = 0;
        tap_avg = 24000;
        tap_active = false;
        tap_last_out_bpm = 0;
        if (clock_playing) { eff_resetPhase = true; tap_reset_hold = 8; }
    } else {
        tap_pool[tap_pool_index] = tap_timer;
        tap_pool_index++;
        tap_pool_index %= tap_beats;
        bool is_beat_one = (tap_pool_index == 0);
        int32_t sum = 0;
        int counted = 0;
        for (int i = 0; i < tap_beats; i++) {
            if (tap_pool[i] != 0) { sum += tap_pool[i]; counted++; }
        }
        if (counted > 0) {
            tap_avg = sum / counted;
            int32_t tap_bpm_calc = (60 * 48000) / tap_avg;
            if (tap_bpm_calc < 40) tap_bpm_calc = 40;
            if (tap_bpm_calc > 300) tap_bpm_calc = 300;
            if (!bpm_from_inlet) {
                tap_bpm = tap_bpm_calc;
                bpm_changed = true;
            }
            if (is_beat_one && counted >= tap_beats) {
                if (inlet_countIn) {
                    if (tap_count_phase == 0 && !clock_playing) {
                        eff_play = true;
                        tap_start_hold = 8;
                        tap_count_phase = 1;
                    } else if (clock_playing) {
                        eff_resetPhase = true;
                        tap_reset_hold = 8;
                    }
                } else if (clock_playing) {
                    eff_resetPhase = true;
                    tap_reset_hold = 8;
                }
            }
        }
    }
    tap_timer = 0;
    tap_active = true;
}

if (tap_timer < tap_wait_samples) tap_active = true;
else tap_active = false;

// Convert tap tempo output to effective inputs for sync clock
// bpm_changed is set by tap tempo logic OR by BPM inlet logic above
if (bpm_changed && tap_bpm != tap_last_out_bpm) {
    eff_setBPM = true;
    eff_bpmValue = tap_bpm;
    tap_last_out_bpm = tap_bpm;
}

// Also respond to setBPM inlet trigger (for direct BPM setting)
// Ignore when value matches current_bpm (feedback from our own output)
if (inlet_setBPM && inlet_bpmValue > 0 && inlet_bpmValue != current_bpm) {
    eff_setBPM = true;
    eff_bpmValue = inlet_bpmValue;
}

// When syncing to external clock, ignore all internal BPM changes
if (use_external) {
    eff_setBPM = false;
}

eff_resetPhase = eff_resetPhase || inlet_resetPhase;
eff_play = eff_play || inlet_play;

// --- Sync clock block (same as sync_clock_musical, using eff_* for BPM/play/reset) ---
current_beats = (inlet_beats > 0) ? inlet_beats : attr_defaultBeats;
current_measure = (inlet_measure > 0) ? inlet_measure : attr_defaultMeasure;
current_lower_bpm = (inlet_lowerBPM > 0) ? inlet_lowerBPM : attr_defaultLowerBPM;
ppq_per_bar = (current_beats * 96) / current_measure;

if (eff_setBPM && !setBPM_trig) {
    setBPM_trig = true;
    if (eff_bpmValue > 0 && detected_bars > 0) {
        old_tempo = smplr.leader_tempo;
        smplr.leader_tempo = bpmToTempo(eff_bpmValue, detected_bars, current_beats, current_measure);
        current_bpm = eff_bpmValue;
        smplr.leader = -1;
        resync = 4;
        ttrig = 1;
        pos = smplr.leader_tempo - 64;
    }
}
if (!eff_setBPM) setBPM_trig = false;

if (eff_play && !play_trig) {
    play_trig = 1;
    clock_playing = 1;
    clock_count = 0;
    prev_clock_pos = 0;
    resync = 4;
    pos = smplr.leader_tempo - 64;
    outlet_reset = 1;
}
if (!eff_play) play_trig = 0;

if (inlet_stop && !stop_trig) {
    stop_trig = 1;
    clock_playing = 0;
}
if (!inlet_stop) stop_trig = 0;

if (inlet_playToggle && !play_toggle_trig) {
    play_toggle_trig = 1;
    clock_playing = !clock_playing;
    if (clock_playing) {
        clock_count = 0;
        prev_clock_pos = 0;
        resync = 4;
        pos = smplr.leader_tempo - 64;
        outlet_reset = 1;
    }
}
if (!inlet_playToggle) play_toggle_trig = 0;

// Match sync_clock_musical: start clock + reset one frame AFTER leader is set (not in trig block)
if (smplr.leader != prev_leader && smplr.leader >= 0 && prev_leader == -1) {
    clock_playing = 1;
    clock_count = 0;
    prev_clock_pos = 0;
    outlet_reset = 1;
}
prev_leader = smplr.leader;

outlet_isPlaying = clock_playing;

if (inlet_EXTsync != presrc){
    presrc = inlet_EXTsync;
    resync = 4;
}

if (inlet_EXTsync){
    sync.syncer_pos = inlet_EXTphase;
    smplr.leader_tempo = inlet_EXTdurSMPS;
    smplr.leader = -1;
    pos = smplr.leader_tempo -64;
    if (sync.syncer_pos < roext) ro = 1;
    roext = sync.syncer_pos;
    outlet_syncPhase = sync.syncer_pos;
    outlet_syncDurSMPS = smplr.leader_tempo;
    outlet_rollover = ro;
    outlet_syncSlot = smplr.leader;
    current_bpm = calculateBPM(smplr.leader_tempo, detected_bars, current_beats, current_measure);
} else {
    if (inlet_setNow && !strig){
        strig = 1;
        trig = 1;
        resync = 4;
    }
    bool doit = 0;
    if (inlet_inSync && !strig){
        strig = 1;
        rosl = smplr.POS;
        if (smplr.PLAY){ wait = 1; waitadr = inlet_toSlot * 128; }
        else doit = 1;
    }
    if (wait){
        adr = waitadr;
        if (smplr.DIRECTION > 0) doit = (smplr.POS < rosl);
        else doit = (smplr.POS > rosl);
        rosl = smplr.POS;
    }
    if (doit){
        trig = 1;
        wait = 0;
        resync = 4;
        adr = inlet_toSlot * 128;
    }
    if (!inlet_inSync && !inlet_setNow) strig = 0;

    if (trig){
        old_tempo = smplr.leader_tempo;
        smplr.leader = inlet_toSlot;
        smplr.STARTPOINT = (smplr.STARTPOINT + (smplr.SPMOD >> 1)) & ((1<<27)-1);
        smplr.SPMOD = 0;
        smplr.leader_start = smplr.STARTPOINT;
        uint32_t stempo;
        if (smplr.RAW || (inlet_setToRaw || attr_setTempoTo)) stempo = smplr.calc_dur(smplr.leader);
        else stempo = smplr.leader_tempo * float(smplr.BARS) / (1<<21);
        int32_t calculated_bars = 1;
        smplr.leader_tempo = scale_tempo_musical(stempo, current_lower_bpm, current_beats, current_measure, &calculated_bars);
        detected_bars = calculated_bars;
        smplr.BARS = sync.calc_bars(stempo, smplr.leader_tempo);
        smplr.RAW = 0;
        pos = smplr.leader_tempo - 64;  // Match sync_clock_musical: no clock start/reset here
        current_bpm = calculateBPM(smplr.leader_tempo, detected_bars, current_beats, current_measure);
    }

    if ((trig || ttrig) && !inlet_NOrecalc){
        count = smplr.slots + 1;
        frac = float(old_tempo) / smplr.leader_tempo;
    }
    if (count){
        count--;
        if (count != smplr.leader){
            adr = count * 128;
            smplr.BARS = smplr.BARS * frac;
            if (!inlet_NOquantize && (!smplr.RAW || !inlet_skipRaw)){
                uint8_t quant = (inlet_quantization) ? inlet_quantization : attr_quantization;
                smplr.BARS = sync.quantize(smplr.BARS, 1<<21, quant) * (1<<21);
                smplr.RAW = 0;
            }
        }
    }
    if (eff_resetPhase && !rtrig){
        rtrig = 1;
        resync = 4;
        pos = smplr.leader_tempo - 64;
        clock_count = 0;
        prev_clock_pos = 0;
        outlet_reset = 1;
    }
    if (!eff_resetPhase) rtrig = 0;
    pos += 16;
    if (pos >= smplr.leader_tempo) ro = 1;
    pos = pos % smplr.leader_tempo;
    sync.syncer_pos = (float(pos) / smplr.leader_tempo) * (1 << 27);

    outlet_syncPhase = sync.syncer_pos;
    outlet_syncDurSMPS = smplr.leader_tempo;
    outlet_rollover = ro;
    outlet_syncSlot = smplr.leader;
}

if (smplr.leader > -1){
    adr = smplr.leader * 128;
    smplr.leader_start = smplr.STARTPOINT;
} else smplr.leader_start = 0;

if (resync){
    sync.resync = -1;
    resync--;
} else sync.resync = 0;

// 24ppq clock generation - mode-dependent
if (clock_playing) {
    // In Ext mode (1), NEVER run internal clock if no external clock
    if (current_clock_mode == 1 && !isClockIncoming) {
        outlet_clock24ppq = 0; // No clock output in Ext mode without external clock
    } else if (current_clock_mode == 1 && isClockIncoming) {
        // Ext mode with external clock: use external MIDI clock pulse
        outlet_clock24ppq = shouldTrigger24Ppq_ext;
        shouldTrigger24Ppq_ext = false; // Clear for next cycle
    } else if (current_clock_mode == 0 && isClockIncoming) {
        // Auto mode with external clock: use external MIDI clock pulse
        outlet_clock24ppq = shouldTrigger24Ppq_ext;
        shouldTrigger24Ppq_ext = false; // Clear for next cycle
    } else {
        // Auto mode without external clock OR Int mode: use internal sync clock
        float actual_bars = (float)detected_bars / 16.0;
        uint32_t total_ppq = (uint32_t)(ppq_per_bar * actual_bars);
        uint32_t current_tick = (sync.syncer_pos * total_ppq) >> 27;
        uint32_t prev_tick = (prev_clock_pos * total_ppq) >> 27;
        if (current_tick != prev_tick || ro) {
            outlet_clock24ppq = 1;
            if (ro) clock_count = 0;
            else clock_count = (clock_count + 1) % total_ppq;
        } else {
            outlet_clock24ppq = 0;
        }
    }
} else {
    outlet_clock24ppq = 0;
}

prev_clock_pos = sync.syncer_pos;

// Write BPM directly to param table when it changes
if (current_bpm != last_written_bpm && current_bpm > 0) {
    param_table->array[attr_bpmPage][attr_bpmParam] = current_bpm;
    last_written_bpm = current_bpm;
}

// Still output to outlet for backward compatibility / monitoring
outlet_bpm = current_bpm;
outlet_detectedBars = detected_bars;
outlet_ppqPerBar = ppq_per_bar;

// Version outlet: increment with each release (v0_0_1 = 1, v0_0_2 = 2, ...)
outlet_v004 = 4;]]></code.krate>
      <code.srate><![CDATA[if (tap_timer < tap_wait_samples) {
    tap_timer++;
}

// External MIDI clock dropout detection
if (isClockIncoming) {
    midi_timer++;
    if (midi_timer >= clockDropoutSamples) {
        isClockIncoming = false; // Clock dropped out
        midi_timer = 0;
    }
} else {
    midi_timer = 0;
}]]></code.srate>
      <code.midihandler><![CDATA[// Handle external MIDI clock messages
if (current_clock_mode == 2) return; // Int mode: ignore external MIDI

switch (status) {
    case MIDI_TIMING_CLOCK:
        measureExternalClock();
        // Auto mode: auto-start if not playing when clock arrives
        if (current_clock_mode == 0 && !clock_playing) {
            clock_playing = true;
            clock_count = 0;
            prev_clock_pos = 0;
            pos = smplr.leader_tempo - 64;
            resync = 4;
        }
        break;
    
    case MIDI_START:
        midiStartReceived = true;
        midi_start_reset_hold = 8; // Trigger reset pulse
        clock_playing = true;
        clock_count = 0;
        prev_clock_pos = 0;
        pos = smplr.leader_tempo - 64;
        resync = 4;
        break;
    
    case MIDI_STOP:
        midiStopReceived = true;
        isClockIncoming = false;
        // Don't stop clock_playing - continue at measured tempo (pickover behavior)
        // User will refine this behavior later with additional parameters
        break;
}]]></code.midihandler>
   </obj.normal>
</objdefs>
