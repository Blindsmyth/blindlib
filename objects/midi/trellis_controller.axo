<objdefs appVersion="1.1.0">
   <obj.normal id="trellis_controller" uuid="c3d4e5f6-a7b8-9012-cdef-345678901234">
      <sDescription>Trellis 8x4 MIDI controller handler (notes 36-67).
Grid layout: 8 columns x 4 rows starting at note 36.

Row 1 (36-43): Rec/Sel buttons for layers 1-4
  - Notes 36,38,40,42: Rec buttons (rec1-4 outlets)
  - Notes 37,39,41,43: Sel/Index buttons (sets index outlet to 1-4)
  - Rec+Sel: stop (immediate), reset (hold > resetTime)
  - Shift+Rec or Shift+Sel: reverse mode

Row 2 (44-51): Reserved (no outlets currently implemented)

Row 3 (52-59): Reserved (no outlets currently implemented)

Row 4 (60-67): Transport and mode selection
  - Note 60: tap (without shift), nudgeMinus (with shift)
  - Note 61: play (without shift), nudgePlus (with shift) 
  - Note 62: shift button (shiftHeld outlet)
  - Note 63: Main mode (index=0), System mode (index=9 with shift)
  - Notes 64-67: Fx(5), Syn(6), Inst(7), Seq(8) modes

Shift button (note 62) enables alternate functions.
All button states available via individual outlets.</sDescription>
      <author>Simon / AI Assistant</author>
      <license>BSD</license>
      <helpPatch>midi.axh</helpPatch>
      <inlets/>
      <outlets>
         <int32 name="index" description="layer/mode index: sel(1-4), main(0), fx(5), syn(6), inst(7), seq(8), system(9)"/>
         <bool32 name="rec1" description="layer 1 rec (note 36 held)"/>
         <bool32 name="rec2" description="layer 2 rec (note 38 held)"/>
         <bool32 name="rec3" description="layer 3 rec (note 40 held)"/>
         <bool32 name="rec4" description="layer 4 rec (note 42 held)"/>
         <bool32.pulse name="stop1" description="layer 1 stop (rec+sel short hold)"/>
         <bool32.pulse name="stop2" description="layer 2 stop (rec+sel short hold)"/>
         <bool32.pulse name="stop3" description="layer 3 stop (rec+sel short hold)"/>
         <bool32.pulse name="stop4" description="layer 4 stop (rec+sel short hold)"/>
         <bool32.pulse name="reset1" description="layer 1 reset (rec+sel long hold)"/>
         <bool32.pulse name="reset2" description="layer 2 reset (rec+sel long hold)"/>
         <bool32.pulse name="reset3" description="layer 3 reset (rec+sel long hold)"/>
         <bool32.pulse name="reset4" description="layer 4 reset (rec+sel long hold)"/>
         <bool32 name="reverse1" description="layer 1 reverse (rec OR sel + shift held)"/>
         <bool32 name="reverse2" description="layer 2 reverse (rec OR sel + shift held)"/>
         <bool32 name="reverse3" description="layer 3 reverse (rec OR sel + shift held)"/>
         <bool32 name="reverse4" description="layer 4 reverse (rec OR sel + shift held)"/>
         <bool32.pulse name="indexTrig" description="pulse when any index button pressed"/>
         <bool32 name="tap" description="note 60 held"/>
         <bool32 name="play" description="note 61 held"/>
         <bool32 name="shift" description="note 62 held"/>
         <bool32 name="nudgeMinus" description="note 60 + shift held"/>
         <bool32 name="nudgePlus" description="note 61 + shift held"/>
         <bool32 name="shiftHeld" description="shift state (held/released)"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <spinner name="resetTime" MinValue="100" MaxValue="10000" DefaultValue="800"/>
      </attribs>
      <code.declaration><![CDATA[// Note gate states - efficient array lookup
bool gate[128];

// State tracking
int8_t current_index;
bool trig_index;

// Previous state tracking for button release detection
bool prev_shift;
bool prev_rec1, prev_sel1;
bool prev_rec2, prev_sel2;
bool prev_rec3, prev_sel3;
bool prev_rec4, prev_sel4;

// Function lock flags - require button release before retriggering
bool rec1_locked, rec2_locked, rec3_locked, rec4_locked;

// Stop/reset timers - track how long combo is held
uint16_t stop_timer1, stop_timer2, stop_timer3, stop_timer4;
bool reset_triggered1, reset_triggered2, reset_triggered3, reset_triggered4;]]></code.declaration>
      <code.init><![CDATA[current_index = 0; // Default to Main (index 0)

// Initialize gate array
for (int i = 0; i < 128; i++) {
    gate[i] = 0;
}

// Initialize previous states and locks
prev_shift = 0;
prev_rec1 = prev_sel1 = 0;
prev_rec2 = prev_sel2 = 0;
prev_rec3 = prev_sel3 = 0;
prev_rec4 = prev_sel4 = 0;
rec1_locked = rec2_locked = rec3_locked = rec4_locked = 0;

// Initialize stop/reset timers
stop_timer1 = stop_timer2 = stop_timer3 = stop_timer4 = 0;
reset_triggered1 = reset_triggered2 = reset_triggered3 = reset_triggered4 = 0;]]></code.init>
      <code.krate><![CDATA[// Shift button state (note 62)
bool shift_held = gate[62];

// ROW 1: Rec/Stop/Reset/Reverse with release-required logic
// Layer 1
bool rec1_held = gate[36];
bool sel1_held = gate[37];
bool combo1 = rec1_held && sel1_held;

// Stop/Reset timing logic
if (combo1 && !shift_held) {
    // Stop fires immediately when combo is pressed
    if (stop_timer1 == 0) {
        outlet_stop1 = 1; // Immediate stop pulse
    } else {
        outlet_stop1 = 0;
    }
    
    stop_timer1++;
    // Trigger reset pulse when threshold reached
    if (stop_timer1 == attr_resetTime) {
        outlet_reset1 = 1;
    } else {
        outlet_reset1 = 0;
    }
} else {
    outlet_stop1 = 0;
    stop_timer1 = 0;
    outlet_reset1 = 0;
}

// Lock rec1 if shift or combo was active
if (shift_held || combo1) {
    rec1_locked = 1;
}
// Unlock only when button is actually released
if (!rec1_held) {
    rec1_locked = 0;
}

outlet_rec1 = !shift_held && rec1_held && !sel1_held && !rec1_locked;
outlet_reverse1 = shift_held && (rec1_held || sel1_held);

// Layer 2
bool rec2_held = gate[38];
bool sel2_held = gate[39];
bool combo2 = rec2_held && sel2_held;

// Stop/Reset timing logic
if (combo2 && !shift_held) {
    // Stop fires immediately when combo is pressed
    if (stop_timer2 == 0) {
        outlet_stop2 = 1; // Immediate stop pulse
    } else {
        outlet_stop2 = 0;
    }
    
    stop_timer2++;
    if (stop_timer2 == attr_resetTime) {
        outlet_reset2 = 1;
    } else {
        outlet_reset2 = 0;
    }
} else {
    outlet_stop2 = 0;
    stop_timer2 = 0;
    outlet_reset2 = 0;
}

if (shift_held || combo2) {
    rec2_locked = 1;
}
if (!rec2_held) {
    rec2_locked = 0;
}

outlet_rec2 = !shift_held && rec2_held && !sel2_held && !rec2_locked;
outlet_reverse2 = shift_held && (rec2_held || sel2_held);

// Layer 3
bool rec3_held = gate[40];
bool sel3_held = gate[41];
bool combo3 = rec3_held && sel3_held;

// Stop/Reset timing logic
if (combo3 && !shift_held) {
    // Stop fires immediately when combo is pressed
    if (stop_timer3 == 0) {
        outlet_stop3 = 1; // Immediate stop pulse
    } else {
        outlet_stop3 = 0;
    }
    
    stop_timer3++;
    if (stop_timer3 == attr_resetTime) {
        outlet_reset3 = 1;
    } else {
        outlet_reset3 = 0;
    }
} else {
    outlet_stop3 = 0;
    stop_timer3 = 0;
    outlet_reset3 = 0;
}

if (shift_held || combo3) {
    rec3_locked = 1;
}
if (!rec3_held) {
    rec3_locked = 0;
}

outlet_rec3 = !shift_held && rec3_held && !sel3_held && !rec3_locked;
outlet_reverse3 = shift_held && (rec3_held || sel3_held);

// Layer 4
bool rec4_held = gate[42];
bool sel4_held = gate[43];
bool combo4 = rec4_held && sel4_held;

// Stop/Reset timing logic
if (combo4 && !shift_held) {
    // Stop fires immediately when combo is pressed
    if (stop_timer4 == 0) {
        outlet_stop4 = 1; // Immediate stop pulse
    } else {
        outlet_stop4 = 0;
    }
    
    stop_timer4++;
    if (stop_timer4 == attr_resetTime) {
        outlet_reset4 = 1;
    } else {
        outlet_reset4 = 0;
    }
} else {
    outlet_stop4 = 0;
    stop_timer4 = 0;
    outlet_reset4 = 0;
}

if (shift_held || combo4) {
    rec4_locked = 1;
}
if (!rec4_held) {
    rec4_locked = 0;
}

outlet_rec4 = !shift_held && rec4_held && !sel4_held && !rec4_locked;
outlet_reverse4 = shift_held && (rec4_held || sel4_held);

// Store previous states for next iteration
prev_shift = shift_held;
prev_rec1 = rec1_held; prev_sel1 = sel1_held;
prev_rec2 = rec2_held; prev_sel2 = sel2_held;
prev_rec3 = rec3_held; prev_sel3 = sel3_held;
prev_rec4 = rec4_held; prev_sel4 = sel4_held;

// Tap and Play (notes 60, 61) - gate outputs
outlet_tap = gate[60] && !shift_held;
outlet_play = gate[61] && !shift_held;

// Shift output
outlet_shift = gate[62];

// Nudge buttons (notes 60+shift, 61+shift) - gate outputs
outlet_nudgeMinus = gate[60] && shift_held;
outlet_nudgePlus = gate[61] && shift_held;

// Index trigger (pulse on index change)
outlet_indexTrig = trig_index;

// Output index
outlet_index = current_index;

// Output shift state
outlet_shiftHeld = shift_held;

// Reset index trigger
trig_index = 0;]]></code.krate>
      <code.midihandler><![CDATA[// Efficient gate array approach
if ((status == MIDI_NOTE_ON + attr_midichannel) && (data2)) {
    gate[data1] = 1;
    
    // Detect shift state for logic (note 62)
    bool shift = gate[62];
    
    // Index buttons - trigger index change
    // Sel buttons (37, 39, 41, 43) when NOT shift
    if (data1 == 37 && !shift) { current_index = 1; trig_index = 1; }
    else if (data1 == 39 && !shift) { current_index = 2; trig_index = 1; }
    else if (data1 == 41 && !shift) { current_index = 3; trig_index = 1; }
    else if (data1 == 43 && !shift) { current_index = 4; trig_index = 1; }
    
    // Row 4 index buttons (63-67) when NOT shift
    else if (data1 == 63 && !shift) { current_index = 0; trig_index = 1; } // Main(0)
    else if (data1 == 64 && !shift) { current_index = 5; trig_index = 1; } // Fx(5)
    else if (data1 == 65 && !shift) { current_index = 6; trig_index = 1; } // Syn(6)
    else if (data1 == 66 && !shift) { current_index = 7; trig_index = 1; } // Inst(7)
    else if (data1 == 67 && !shift) { current_index = 8; trig_index = 1; } // Seq(8)
    
    // System: Shift+Main (shift+63)
    else if (data1 == 63 && shift) { current_index = 9; trig_index = 1; }
}

// Note Off handler
if (((status == MIDI_NOTE_ON + attr_midichannel) && (!data2)) || (status == MIDI_NOTE_OFF + attr_midichannel)) {
    gate[data1] = 0;
}

// All Notes Off
if ((status == attr_midichannel + MIDI_CONTROL_CHANGE) && (data1 == MIDI_C_ALL_NOTES_OFF)) {
    for (int i = 0; i < 128; i++) {
        gate[i] = 0;
    }
}]]></code.midihandler>
   </obj.normal>
</objdefs>