<objdefs appVersion="1.1.0">
   <obj.normal id="trellis_led_feedback_combined" uuid="5224773f-18de-4231-8f92-b1f22bb9539B">
      <sDescription>Combined Trellis LED feedback for both shift modes. When shift is ON: shows reverse/alt toggle states. When shift is OFF: shows looper states as velocities.</sDescription>
      <author>AI Assistant</author>
      <license>BSD</license>
      <helpPatch>midi.axh</helpPatch>
      <inlets>
         <bool32 name="shift" description="Shift state - ON=toggle mode, OFF=looper mode"/>
         <bool32 name="reverse1" description="Layer 1 reverse state (shift mode)"/>
         <bool32 name="reverse2" description="Layer 2 reverse state (shift mode)"/>
         <bool32 name="reverse3" description="Layer 3 reverse state (shift mode)"/>
         <bool32 name="reverse4" description="Layer 4 reverse state (shift mode)"/>
         <bool32 name="alt1" description="Layer 1 alt state (shift mode)"/>
         <bool32 name="alt2" description="Layer 2 alt state (shift mode)"/>
         <bool32 name="alt3" description="Layer 3 alt state (shift mode)"/>
         <bool32 name="alt4" description="Layer 4 alt state (shift mode)"/>
         <int32 name="state0" description="Looper state 0 (shift OFF mode)"/>
         <int32 name="state1" description="Looper state 1 (shift OFF mode)"/>
         <int32 name="state2" description="Looper state 2 (shift OFF mode)"/>
      </inlets>
      <outlets/>
      <displays/>
      <params>
         <int32 name="startnote" noLabel="true">
            <MinValue i="0"/>
            <MaxValue i="127"/>
         </int32>
      </params>
      <attribs>
         <spinner name="revVelocity" MinValue="0" MaxValue="127" DefaultValue="19"/>
         <spinner name="altVelocity" MinValue="0" MaxValue="127" DefaultValue="60"/>
         <spinner name="midichannel" MinValue="1" MaxValue="16" DefaultValue="1"/>
         <combo name="device">
            <MenuEntries>
               <string>din</string>
               <string>usb host port 1</string>
               <string>usb host port 2</string>
               <string>usb host port 3</string>
               <string>usb host port 4</string>
               <string>internal port 1</string>
               <string>internal port 2</string>
               <string>usb device port 1</string>
            </MenuEntries>
            <CEntries>
               <string>MIDI_DEVICE_DIN, 1</string>
               <string>MIDI_DEVICE_USB_HOST, 1</string>
               <string>MIDI_DEVICE_USB_HOST, 2</string>
               <string>MIDI_DEVICE_USB_HOST, 3</string>
               <string>MIDI_DEVICE_USB_HOST, 4</string>
               <string>MIDI_DEVICE_INTERNAL, 1</string>
               <string>MIDI_DEVICE_INTERNAL, 2</string>
               <string>MIDI_DEVICE_USB_DEVICE, 1</string>
            </CEntries>
         </combo>
      </attribs>
      <includes/>
      <code.declaration><![CDATA[// Define the array of velocity values for looper state mapping
uint8_t velocities[5] = {0, 3, 0, 19, 60};

// Previous toggle states for shift mode change detection
bool prev_rev1, prev_rev2, prev_rev3, prev_rev4;
bool prev_alt1, prev_alt2, prev_alt3, prev_alt4;

// Previous looper states for non-shift mode change detection
uint8_t prev_looper0, prev_looper1, prev_looper2;

// Previous shift state for edge detection
bool prev_shift;

uint8_t startnote;]]></code.declaration>
      <code.init><![CDATA[// Initialize previous states
prev_rev1 = prev_rev2 = prev_rev3 = prev_rev4 = 0;
prev_alt1 = prev_alt2 = prev_alt3 = prev_alt4 = 0;
prev_looper0 = prev_looper1 = prev_looper2 = 0;
prev_shift = 0;]]></code.init>
      <code.krate><![CDATA[startnote = param_startnote;

// Convert inlets to bool
bool shift_pressed = inlet_shift > 0;
bool rev1 = inlet_reverse1 > 0;
bool rev2 = inlet_reverse2 > 0;
bool rev3 = inlet_reverse3 > 0;
bool rev4 = inlet_reverse4 > 0;
bool alt1 = inlet_alt1 > 0;
bool alt2 = inlet_alt2 > 0;
bool alt3 = inlet_alt3 > 0;
bool alt4 = inlet_alt4 > 0;

// Check for shift rising edge (0 to 1)
bool shift_rising = shift_pressed && !prev_shift;

if (shift_pressed) {
    // SHIFT MODE: Show reverse/alt toggle states
    // On shift rising edge, send all current states (including OFF states with NOTE OFF)
    if (shift_rising) {
        // Send all reverse states - use NOTE_ON with velocity (0 for OFF)
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 37, rev1 ? attr_revVelocity : 0);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 39, rev2 ? attr_revVelocity : 0);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 41, rev3 ? attr_revVelocity : 0);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 43, rev4 ? attr_revVelocity : 0);
        
        // Send all alt states - use NOTE_ON with velocity (0 for OFF)
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 36, alt1 ? attr_altVelocity : 0);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 38, alt2 ? attr_altVelocity : 0);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 40, alt3 ? attr_altVelocity : 0);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 42, alt4 ? attr_altVelocity : 0);
        
        // Update previous states
        prev_rev1 = rev1; prev_rev2 = rev2; prev_rev3 = rev3; prev_rev4 = rev4;
        prev_alt1 = alt1; prev_alt2 = alt2; prev_alt3 = alt3; prev_alt4 = alt4;
    } else {
        // Normal operation: send only when states change
        if (rev1 != prev_rev1) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 37, rev1 ? attr_revVelocity : 0);
            prev_rev1 = rev1;
        }
        if (rev2 != prev_rev2) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 39, rev2 ? attr_revVelocity : 0);
            prev_rev2 = rev2;
        }
        if (rev3 != prev_rev3) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 41, rev3 ? attr_revVelocity : 0);
            prev_rev3 = rev3;
        }
        if (rev4 != prev_rev4) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 43, rev4 ? attr_revVelocity : 0);
            prev_rev4 = rev4;
        }
        
        if (alt1 != prev_alt1) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 36, alt1 ? attr_altVelocity : 0);
            prev_alt1 = alt1;
        }
        if (alt2 != prev_alt2) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 38, alt2 ? attr_altVelocity : 0);
            prev_alt2 = alt2;
        }
        if (alt3 != prev_alt3) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 40, alt3 ? attr_altVelocity : 0);
            prev_alt3 = alt3;
        }
        if (alt4 != prev_alt4) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 42, alt4 ? attr_altVelocity : 0);
            prev_alt4 = alt4;
        }
    }
} else {
    // NON-SHIFT MODE: Show looper states as velocities
    // Convert states to velocities
    uint8_t vel0 = velocities[inlet_state0];
    uint8_t vel1 = velocities[inlet_state1];
    uint8_t vel2 = velocities[inlet_state2];

    // Check for shift falling edge (1 to 0) - this is when looper mode becomes active
    bool shift_falling = !shift_pressed && prev_shift;

    // On shift falling edge, send all states regardless of previous values
    if (shift_falling) {
        // First turn off all toggle LEDs (reverse and alt)
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 37, 0); // rev1
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 39, 0); // rev2
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 41, 0); // rev3
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 43, 0); // rev4
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 36, 0); // alt1
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 38, 0); // alt2
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 40, 0); // alt3
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), 42, 0); // alt4
        
        // Then send all looper states - use NOTE_ON with velocity (0 for OFF)
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), startnote, vel0);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), startnote + 2, vel1);
        MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), startnote + 4, vel2);
        prev_looper0 = vel0;
        prev_looper1 = vel1;
        prev_looper2 = vel2;
    } else {
        // Normal operation: send only when velocity changes
        if (vel0 != prev_looper0) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), startnote, vel0);
            prev_looper0 = vel0;
        }
        if (vel1 != prev_looper1) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), startnote + 2, vel1);
            prev_looper1 = vel1;
        }
        if (vel2 != prev_looper2) {
            MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1), startnote + 4, vel2);
            prev_looper2 = vel2;
        }
    }
}

// Update previous shift state
prev_shift = shift_pressed;]]></code.krate>
   </obj.normal>
</objdefs>
