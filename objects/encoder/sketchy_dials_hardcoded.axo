<objdefs appVersion="1.1.0">
  <obj.normal id="sketchy_dials_hardcoded" uuid="5224773f-18de-4231-8f92-b1f22bb953B5">
    <sDescription>Hardcoded 16-page dial configuration optimized for 4-track looper. All page configs are embedded in the object.</sDescription>
    <author>Simon / AI Assistant</author>
    <license>BSD</license>
    <helpPatch>logic.axh</helpPatch>
    <inlets>
      <int32 name="page"/>
    </inlets>
    <outlets/>
    <displays/>
    <params/>
    <attribs>
      <spinner name="maxpages" description="Maximum number of pages (8-64)" MinValue="8" MaxValue="64" DefaultValue="16"/>
    </attribs>
    <depends>
      <depend>sketchy_font</depend>
      <depend>sketchy_params</depend>
      <depend>sketchy_render</depend>
      <depend>sketchy_objects</depend>
      <depend>sketchy_texts</depend>
    </depends>
    <code.declaration><![CDATA[// Dial configuration structure
typedef struct {
    uint8_t mode;           // 0=frac unipolar, 1=frac bipolar, 2=int, 3=list, 4=bar unipolar, 5=bar bipolar, 6=duplicate
    bool show_value;        // Show/hide value (for fractional modes)
    const char* label;      // Label text
    const char* options;    // List options (for mode 3) OR duplicate reference "page,dial" (for mode 6)
    float default_value;    // Default value
    int16_t int_min;        // Minimum value (for int/list modes)
    int16_t int_max;        // Maximum value (for int/list modes)
} encoder_dial_config_t;

// Configuration storage - pointer to SDRAM array
encoder_dial_config_t (*configs)[8];

// Mode constants
#define MODE_FRAC_UNIPOLAR 0  // 0.0 to 1.0, positive only
#define MODE_FRAC_BIPOLAR  1  // -1.0 to 1.0, bipolar
#define MODE_INT           2  // min to max, integer
#define MODE_LIST          3  // selector mode
#define MODE_BAR_UNIPOLAR  4  // 0.0 to 1.0, vertical bar
#define MODE_BAR_BIPOLAR   5  // -1.0 to 1.0, vertical bar
#define MODE_DUPLICATE     6  // duplicate another parameter
#define MODE_EMPTY         255 // empty/unconfigured - no display object created

// Display structures - pointers to SDRAM arrays
rootc::objectinstance_sketchy__render::dial_t *dials;
rootc::objectinstance_sketchy__render::intdisplay_t *intdisplays;
rootc::objectinstance_sketchy__render::select_t *selects;
rootc::objectinstance_sketchy__render::bar_t *bars;

// SDRAM arrays - declared here to prevent init-time allocation issues
// Support 16 pages * 8 = 128 dials (non-static member arrays in SDRAM)
rootc::objectinstance_sketchy__render::dial_t _dials[128] __attribute__ ((section (".sdram")));
rootc::objectinstance_sketchy__render::intdisplay_t _intdisplays[128] __attribute__ ((section (".sdram")));
rootc::objectinstance_sketchy__render::select_t _selects[128] __attribute__ ((section (".sdram")));
rootc::objectinstance_sketchy__render::bar_t _bars[128] __attribute__ ((section (".sdram")));
encoder_dial_config_t _configs[16][8] __attribute__ ((section (".sdram")));

// Fixed layout positions
const uint8_t DIAL_WIDTH = 24;
const uint8_t DIAL_HEIGHT = 24;
const uint8_t ROW1_Y = 13;
const uint8_t ROW2_Y = 39;
const uint8_t COL_X[4] = {26, 52, 78, 104};

// Convert from display value to encoder position (0-1)
float displayToEncoderValue(float displayValue, int mode) {
    switch(mode) {
        case MODE_FRAC_UNIPOLAR:
        case MODE_BAR_UNIPOLAR:
            return displayValue / 64.0f;
        case MODE_FRAC_BIPOLAR:
        case MODE_BAR_BIPOLAR:
            return (displayValue + 64.0f) / 128.0f;
        case MODE_INT:
        case MODE_LIST:
            return 0.0f;
        default:
            return displayValue;
    }
}

// Parse duplicate reference "page,dial" into page and dial indices
void parse_duplicate_reference(const char* options, uint8_t* ref_page, uint8_t* ref_dial) {
    *ref_page = 0;
    *ref_dial = 0;
    
    if (options && strlen(options) >= 3) {
        *ref_page = options[0] - '0';
        if (options[1] == ',' && options[2] >= '0' && options[2] <= '7') {
            *ref_dial = options[2] - '0';
        }
    }
}

// Initialize a single dial based on its configuration
void init_dial(uint8_t page, uint8_t dial_index, const encoder_dial_config_t* config) {
    uint8_t array_index = page * 8 + dial_index;
    
    if (array_index >= (attr_maxpages * 8)) {
        return;
    }
    
    float encoder_pos;
    
    switch (config->mode) {
        case MODE_EMPTY:
            return;
            
        case MODE_FRAC_UNIPOLAR:
        case MODE_FRAC_BIPOLAR:
            dials[array_index].page = page;
            dials[array_index].param = dial_index;
            dials[array_index].is_bipolar = (config->mode == MODE_FRAC_BIPOLAR);
            dials[array_index].x = COL_X[dial_index % 4];
            dials[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            dials[array_index].width = DIAL_WIDTH;
            dials[array_index].height = DIAL_HEIGHT;
            dials[array_index].label = config->label;
            dials[array_index].show_value = config->show_value;
            encoder_pos = displayToEncoderValue(config->default_value, config->mode);
            if (encoder_pos < 0.0f) encoder_pos = 0.0f;
            if (encoder_pos > 1.0f) encoder_pos = 1.0f;
            dials[array_index].default_value = (int32_t)(encoder_pos * (float)(1 << 27));
            parent->objectinstance_sketchy__render_i.dial_init(&dials[array_index]);
            break;
            
        case MODE_BAR_UNIPOLAR:
        case MODE_BAR_BIPOLAR:
            bars[array_index].page = page;
            bars[array_index].param = dial_index;
            bars[array_index].is_bipolar = (config->mode == MODE_BAR_BIPOLAR);
            bars[array_index].x = COL_X[dial_index % 4];
            bars[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            bars[array_index].width = DIAL_WIDTH;
            bars[array_index].height = DIAL_HEIGHT;
            bars[array_index].label = config->label;
            bars[array_index].show_value = config->show_value;
            encoder_pos = displayToEncoderValue(config->default_value, config->mode);
            if (encoder_pos < 0.0f) encoder_pos = 0.0f;
            if (encoder_pos > 1.0f) encoder_pos = 1.0f;
            bars[array_index].default_value = (int32_t)(encoder_pos * (float)(1 << 27));
            parent->objectinstance_sketchy__render_i.bar_init(&bars[array_index]);
            break;
            
        case MODE_INT:
            intdisplays[array_index].page = page;
            intdisplays[array_index].param = dial_index;
            intdisplays[array_index].x = COL_X[dial_index % 4];
            intdisplays[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            intdisplays[array_index].width = DIAL_WIDTH;
            intdisplays[array_index].height = DIAL_HEIGHT;
            intdisplays[array_index].label = config->label;
            parent->objectinstance_sketchy__render_i.intdisplay_init(&intdisplays[array_index]);
            break;
            
        case MODE_LIST:
            selects[array_index].page = page;
            selects[array_index].param = dial_index;
            selects[array_index].x = COL_X[dial_index % 4];
            selects[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            selects[array_index].width = DIAL_WIDTH;
            selects[array_index].height = DIAL_HEIGHT;
            selects[array_index].is_int = true;
            selects[array_index].param_label = config->label;
            selects[array_index].options = config->options;
            parent->objectinstance_sketchy__render_i.select_init(&selects[array_index]);
            break;
            
        case MODE_DUPLICATE:
            uint8_t ref_page, ref_dial;
            parse_duplicate_reference(config->options, &ref_page, &ref_dial);
            
            if (ref_page < attr_maxpages && ref_dial < 8) {
                const encoder_dial_config_t* ref_config = &configs[ref_page][ref_dial];
                
                if (ref_config->mode != MODE_DUPLICATE) {
                    encoder_dial_config_t temp_config = *ref_config;
                    init_dial(page, dial_index, &temp_config);
                    
                    switch (temp_config.mode) {
                        case MODE_FRAC_UNIPOLAR:
                        case MODE_FRAC_BIPOLAR:
                            dials[array_index].param = ref_dial;
                            dials[array_index].page = ref_page;
                            break;
                        case MODE_BAR_UNIPOLAR:
                        case MODE_BAR_BIPOLAR:
                            bars[array_index].param = ref_dial;
                            bars[array_index].page = ref_page;
                            break;
                        case MODE_INT:
                            intdisplays[array_index].param = ref_dial;
                            intdisplays[array_index].page = ref_page;
                            break;
                        case MODE_LIST:
                            selects[array_index].param = ref_dial;
                            selects[array_index].page = ref_page;
                            break;
                    }
                }
            }
            break;
    }
}

// Update a single dial based on its configuration
void update_dial(uint8_t page, uint8_t dial_index, const encoder_dial_config_t* config) {
    uint8_t array_index = page * 8 + dial_index;
    
    if (array_index >= (attr_maxpages * 8)) {
        return;
    }
    
    switch (config->mode) {
        case MODE_EMPTY:
            return;
            
        case MODE_FRAC_UNIPOLAR:
        case MODE_FRAC_BIPOLAR:
            parent->objectinstance_sketchy__render_i.dial_update(&dials[array_index]);
            break;
            
        case MODE_BAR_UNIPOLAR:
        case MODE_BAR_BIPOLAR:
            parent->objectinstance_sketchy__render_i.bar_update(&bars[array_index]);
            break;
            
        case MODE_INT:
            parent->objectinstance_sketchy__render_i.intdisplay_update(&intdisplays[array_index]);
            break;
            
        case MODE_LIST:
            parent->objectinstance_sketchy__render_i.select_update(&selects[array_index]);
            break;
            
        case MODE_DUPLICATE:
            uint8_t ref_page, ref_dial;
            parse_duplicate_reference(config->options, &ref_page, &ref_dial);
            
            if (ref_page < attr_maxpages && ref_dial < 8) {
                const encoder_dial_config_t* ref_config = &configs[ref_page][ref_dial];
                
                if (ref_config->mode != MODE_DUPLICATE) {
                    switch (ref_config->mode) {
                        case MODE_FRAC_UNIPOLAR:
                        case MODE_FRAC_BIPOLAR:
                            parent->objectinstance_sketchy__render_i.dial_update(&dials[array_index]);
                            break;
                        case MODE_BAR_UNIPOLAR:
                        case MODE_BAR_BIPOLAR:
                            parent->objectinstance_sketchy__render_i.bar_update(&bars[array_index]);
                            break;
                        case MODE_INT:
                            parent->objectinstance_sketchy__render_i.intdisplay_update(&intdisplays[array_index]);
                            break;
                        case MODE_LIST:
                            parent->objectinstance_sketchy__render_i.select_update(&selects[array_index]);
                            break;
                    }
                }
            }
            break;
    }
}

// Initialize param table with default values
void init_param_table() {
    rootc::objectinstance_sketchy__params* param_table = &parent->objectinstance_sketchy__params_i;
    
    for (int page = 0; page < attr_maxpages; page++) {
        for (int enc = 0; enc < 8; enc++) {
            const encoder_dial_config_t* config = &configs[page][enc];
            
            if (config->mode == MODE_EMPTY) {
                param_table->array[page][enc] = 0;
            } else if (config->mode == MODE_INT || config->mode == MODE_LIST) {
                int default_int = (int)config->default_value;
                if (default_int < config->int_min) default_int = config->int_min;
                if (default_int > config->int_max) default_int = config->int_max;
                param_table->array[page][enc] = default_int;
            } else {
                float encoder_pos = displayToEncoderValue(config->default_value, config->mode);
                if (encoder_pos < 0.0f) encoder_pos = 0.0f;
                if (encoder_pos > 1.0f) encoder_pos = 1.0f;
                param_table->array[page][enc] = (int32_t)(encoder_pos * (float)(1 << 27));
            }
        }
    }
}
]]></code.declaration>
    <code.init><![CDATA[// Point pointers to SDRAM arrays (arrays declared in code.declaration)
dials = &_dials[0];
intdisplays = &_intdisplays[0];
selects = &_selects[0];
bars = &_bars[0];
configs = _configs;

// Initialize hardcoded configuration data directly in SDRAM

// PAGE 0 - Main Page
configs[0][0] = (encoder_dial_config_t){6, false, "PNS", "5,0", 8.0f, 0, 127};
configs[0][1] = (encoder_dial_config_t){6, false, "DEC", "5,1", 64.0f, 0, 127};
configs[0][2] = (encoder_dial_config_t){6, false, "CUT", "5,2", 64.0f, 0, 127};
configs[0][3] = (encoder_dial_config_t){0, false, "FX", "", 16.0f, 0, 127};
configs[0][4] = (encoder_dial_config_t){6, false, "", "1,0", 64.0f, 0, 64};
configs[0][5] = (encoder_dial_config_t){6, false, "2VOL", "2,0", 48.0f, 0, 64};
configs[0][6] = (encoder_dial_config_t){6, false, "3VOL", "3,0", 35.0f, 0, 64};
configs[0][7] = (encoder_dial_config_t){6, false, "4VOL", "4,0", 20.0f, 0, 64};

// PAGE 1 - Layer 1
configs[1][0] = (encoder_dial_config_t){4, false, "1VOL", "", 64.0f, 0, 127};
configs[1][1] = (encoder_dial_config_t){2, false, "OCT", "", 0.0f, -4, 4};
configs[1][2] = (encoder_dial_config_t){2, false, "PTCH", "", 0.0f, -12, 12};
configs[1][3] = (encoder_dial_config_t){3, false, "PDIR", "FWD,REV", 0.0f, 0, 1};
configs[1][4] = (encoder_dial_config_t){2, true,  "HITS", "", 4.0f, 1, 16};
configs[1][5] = (encoder_dial_config_t){2, true,  "LEN", "", 16.0f, 1, 16};
configs[1][6] = (encoder_dial_config_t){2, false, "OFST", "", 0.0f, 0, 15};
configs[1][7] = (encoder_dial_config_t){3, false, "SDIR", "FWD,REV", 0.0f, 0, 1};

// PAGE 2 - Layer 2
configs[2][0] = (encoder_dial_config_t){4, false, "2VOL", "", 48.0f, 0, 127};
configs[2][1] = (encoder_dial_config_t){2, false, "OCT", "", 0.0f, -4, 4};
configs[2][2] = (encoder_dial_config_t){2, false, "PTCH", "", 0.0f, -12, 12};
configs[2][3] = (encoder_dial_config_t){3, false, "PDIR", "FWD,REV", 0.0f, 0, 1};
configs[2][4] = (encoder_dial_config_t){2, true,  "HITS", "", 4.0f, 1, 16};
configs[2][5] = (encoder_dial_config_t){2, true,  "LEN", "", 16.0f, 1, 16};
configs[2][6] = (encoder_dial_config_t){2, false, "OFST", "", 0.0f, 0, 15};
configs[2][7] = (encoder_dial_config_t){3, false, "SDIR", "FWD,REV", 0.0f, 0, 1};

// PAGE 3 - Layer 3
configs[3][0] = (encoder_dial_config_t){4, false, "3VOL", "", 36.0f, 0, 127};
configs[3][1] = (encoder_dial_config_t){2, false, "OCT", "", 0.0f, -4, 4};
configs[3][2] = (encoder_dial_config_t){2, false, "PTCH", "", 0.0f, -12, 12};
configs[3][3] = (encoder_dial_config_t){3, false, "PDIR", "FWD,REV", 0.0f, 0, 1};
configs[3][4] = (encoder_dial_config_t){2, true,  "HITS", "", 4.0f, 1, 16};
configs[3][5] = (encoder_dial_config_t){2, true,  "LEN", "", 16.0f, 1, 16};
configs[3][6] = (encoder_dial_config_t){2, false, "OFST", "", 0.0f, 0, 15};
configs[3][7] = (encoder_dial_config_t){3, false, "SDIR", "FWD,REV", 0.0f, 0, 1};

// PAGE 4 - Layer 4
configs[4][0] = (encoder_dial_config_t){4, false, "4VOL", "", 28.0f, 0, 127};
configs[4][1] = (encoder_dial_config_t){2, false, "OCT", "", 0.0f, -4, 4};
configs[4][2] = (encoder_dial_config_t){2, false, "PTCH", "", 0.0f, -12, 12};
configs[4][3] = (encoder_dial_config_t){3, false, "PDIR", "FWD,REV", 0.0f, 0, 1};
configs[4][4] = (encoder_dial_config_t){2, true,  "HITS", "", 4.0f, 1, 16};
configs[4][5] = (encoder_dial_config_t){2, true,  "LEN", "", 16.0f, 1, 16};
configs[4][6] = (encoder_dial_config_t){2, false, "OFST", "", 0.0f, 0, 15};
configs[4][7] = (encoder_dial_config_t){3, false, "SDIR", "FWD,REV", 0.0f, 0, 1};

// PAGE 5 - Env + Filter Controls
configs[5][0] = (encoder_dial_config_t){0, false, "ATK", "", 8.0f, 0, 127};
configs[5][1] = (encoder_dial_config_t){0, false, "DEC", "", 64.0f, 0, 127};
configs[5][2] = (encoder_dial_config_t){0, false, "CUT", "", 64.0f, 0, 127};
configs[5][3] = (encoder_dial_config_t){0, false, "Q", "", 4.0f, 0, 127};
configs[5][4] = (encoder_dial_config_t){2, false, "THRS", "", 48.0f, 0, 5};
configs[5][5] = (encoder_dial_config_t){1, false, "EG2F", "", 0.0f, -127, 127};
configs[5][6] = (encoder_dial_config_t){0, false, "SLD", "", 0.0f, 0, 127};
configs[5][7] = (encoder_dial_config_t){4, false, "NOIS", "", 0.0f, 0, 1};

// PAGE 6 - Fx Controls
configs[6][0] = (encoder_dial_config_t){0, false, "DlyS", "", 20.0f, -127, 127};
configs[6][1] = (encoder_dial_config_t){0, false, "DFdk", "", 20.0f, -127, 127};
configs[6][2] = (encoder_dial_config_t){0, false, "Shim", "", 20.0f, -127, 127};
configs[6][3] = (encoder_dial_config_t){3, false, "Dsub", "1/16,2/16,3/16,1/4,5/16,3/8,1/2,1/1", 2, 0, 7};
configs[6][4] = (encoder_dial_config_t){0, false, "RvbS", "", 20.0f, 0, 3};
configs[6][5] = (encoder_dial_config_t){0, false, "Rfbk", "", 32.0f, 0, 3};
configs[6][6] = (encoder_dial_config_t){0, false, "D2Vb", "", 20.0f, 0, 127};
configs[6][7] = (encoder_dial_config_t){1, false, "Dtim", "", 0.0f, 0, 100};

// PAGE 7 - Recording / Dub controls
configs[7][0] = (encoder_dial_config_t){0, false,  "FDBK", "", 32.0f, 0, 127};
configs[7][1] = (encoder_dial_config_t){3, false, "MODE", "MAN,1BAR,2BAR,3BAR,4BAR", 1, 0, 4};
configs[7][2] = (encoder_dial_config_t){1, false, "SOFF", "", 0, 0, 127};
configs[7][3] = (encoder_dial_config_t){2, true,  "TRS", "", 0.0f, -24, 24};
configs[7][4] = (encoder_dial_config_t){3, false, "FX2L", "OFF,ON", 1, 0, 1};
configs[7][5] = (encoder_dial_config_t){0, false, "POR", "", 0.0f, 0, 127};
configs[7][6] = (encoder_dial_config_t){2, false, "CHN", "", 1.0f, 1, 16};
configs[7][7] = (encoder_dial_config_t){3, false, "PLY", "Poly,Mono,Leg", 0.0f, 0, 2};

// PAGE 8 - Seq
configs[8][0] = (encoder_dial_config_t){2, true,  "HITS", "", 4.0f, 1, 16};
configs[8][1] = (encoder_dial_config_t){2, true,  "LEN", "", 16.0f, 1, 16};
configs[8][2] = (encoder_dial_config_t){2, false, "OFST", "", 0.0f, 0, 15};
configs[8][3] = (encoder_dial_config_t){3, false, "SDIR", "FWD,REV", 0.0f, 0, 1};
configs[8][4] = (encoder_dial_config_t){2, false, "Time", "", 4.0f, 0, 20};
configs[8][5] = (encoder_dial_config_t){3, false,  "/Sig", "1,2,4,8,16", 4.0f, 0, 4};
configs[8][6] = (encoder_dial_config_t){2, false, "CHN", "", 1.0f, 1, 16};
configs[8][7] = (encoder_dial_config_t){3, false, "PLY", "Poly,Mono,Leg", 0.0f, 0, 2};

// PAGE 9 - System Controls
configs[9][0] = (encoder_dial_config_t){2, false,  "BPM", "", 120.0f, 0, 999};
configs[9][1] = (encoder_dial_config_t){2, false, "fine", "", 0.0f, 0, 99};
configs[9][2] = (encoder_dial_config_t){3, false, "Sync", "Auto,Cont,Int,Ext", 0.0f, 0, 3};
configs[9][3] = (encoder_dial_config_t){3, false,  "Src", "Omni,Auto,UsbH,UsbD,Din", 4.0f, 0, 4};
configs[9][4] = (encoder_dial_config_t){2, false, "Time", "", 4.0f, 0, 20};
configs[9][5] = (encoder_dial_config_t){3, false,  "/Sig", "1,2,4,8,16", 4.0f, 0, 4};
configs[9][6] = (encoder_dial_config_t){2, false, "CHN", "", 1.0f, 1, 16};
configs[9][7] = (encoder_dial_config_t){3, false, "PLY", "Poly,Mono,Leg", 0.0f, 0, 2};

// Initialize remaining pages as empty (no display objects created)
for (int page = 10; page < 16; page++) {
    for (int dial = 0; dial < 8; dial++) {
        configs[page][dial] = (encoder_dial_config_t){255, false, "", "", 0.0f, 0, 127};
    }
}

// Initialize param table with default values
init_param_table();

// Initialize all dials for all pages
for (uint8_t page = 0; page < attr_maxpages; page++) {
    for (uint8_t dial = 0; dial < 8; dial++) {
        init_dial(page, dial, &configs[page][dial]);
    }
}]]></code.init>
    <code.krate><![CDATA[int page = inlet_page;

// Update displays for current page only
if (page >= 0 && page < attr_maxpages) {
    for (uint8_t dial = 0; dial < 8; dial++) {
        uint8_t array_index = page * 8 + dial;
        if (array_index < (attr_maxpages * 8)) {
            const encoder_dial_config_t* config = &configs[page][dial];
            update_dial(page, dial, config);
        }
    }
}]]></code.krate>
  </obj.normal>
</objdefs>
