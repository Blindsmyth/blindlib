<objdefs appVersion="1.0.12">
   <obj.normal id="sketchy_params_midi_send_fixed" uuid="5224773f-18de-4231-8f92-b1f22bb953AA">
      <sDescription>Fixed version: Sends parameters from sketchy_param table as MIDI CC messages with improved throttling and no duplicate sends. Only scans the active page for better responsiveness.</sDescription>
      <author>AI Assistant / Simon</author>
      <license>BSD</license>
      <inlets>
         <int32 name="page" description="Current page to send (0-based)"/>
         <int32 name="startcc" description="Starting CC number"/>
         <bool32.rising name="redraw" description="Force resend all parameters on current page"/>
         <bool32 name="active" description="Enable/disable sending"/>
      </inlets>
      <outlets/>
      <displays/>
      <params/>
      <attribs>
         <spinner name="channel" description="MIDI channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
         <spinner name="maxparams" description="Parameters per page" MinValue="1" MaxValue="8" DefaultValue="8"/>
         <spinner name="maxpages" description="Maximum pages for redraw" MinValue="1" MaxValue="64" DefaultValue="9"/>
      </attribs>
      <includes/>
      <depends>
         <depend>SD2</depend>
         <depend>sketchy_params</depend>
         <depend>sketchy_dials</depend>
      </depends>
      <code.declaration><![CDATA[// Track current page parameters for normal operation
int32_t prev[8];
uint8_t ntrig[8];
int8_t last_page = -1;
uint8_t scan_index;

// Redraw state machine
uint8_t redraw_active;
uint16_t redraw_page;
uint8_t redraw_param;

// Mode constants for duplicate detection
#define MODE_DUPLICATE     6

void SendMidi3(uint8_t b0, uint8_t b1, uint8_t b2) {
    sdPut(&SD2, b0);
    sdPut(&SD2, b1);
    sdPut(&SD2, b2);
}

// Function to convert param value to MIDI CC range (0-127)
uint8_t paramValueToMidiCC(int32_t value) {
    // Convert frac32 format (27-bit) to 7-bit MIDI CC
    // value range: 0 to (1<<27) maps to 0-127
    return (uint8_t)(__USAT(value >> 20, 7));
}

// Parse duplicate reference "page,dial" into page and dial indices
void parse_duplicate_reference(const char* options, uint8_t* ref_page, uint8_t* ref_dial) {
    *ref_page = 0;
    *ref_dial = 0;
    
    // Parse "page,dial" format - supports multi-digit pages
    if (options && strlen(options) >= 3) {
        // Parse page number (can be multi-digit)
        int page_val = 0;
        int i = 0;
        while (options[i] >= '0' && options[i] <= '9') {
            page_val = page_val * 10 + (options[i] - '0');
            i++;
        }
        *ref_page = page_val;
        
        // Find comma and parse dial number (single digit)
        if (options[i] == ',' && options[i+1] >= '0' && options[i+1] <= '7') {
            *ref_dial = options[i+1] - '0';
        }
    }
}

// Resolve duplicate reference to get actual page/dial for MIDI CC calculation
// Returns true if this is a duplicate, false otherwise
bool resolve_duplicate_for_midi(int page, int dial, int* target_page, int* target_dial) {
    auto& config = parent->objectinstance_sketchy__dials_i.configs[page][dial];
    
    if (config.mode == MODE_DUPLICATE) {
        uint8_t ref_page, ref_dial;
        parse_duplicate_reference(config.options, &ref_page, &ref_dial);
        
        if (ref_page < 64 && ref_dial < 8) {
            *target_page = ref_page;
            *target_dial = ref_dial;
            return true;  // This is a duplicate
        }
    }
    
    // Not a duplicate, use current
    *target_page = page;
    *target_dial = dial;
    return false;
}]]></code.declaration>
      <code.init><![CDATA[// Initialize tracking arrays
for (int i = 0; i < 8; i++) {
    prev[i] = 0x7FFFFFFF; // Force initial send with impossible value
    ntrig[i] = 0;
}
last_page = -1;
scan_index = 0;
redraw_active = 0;
redraw_page = 0;
redraw_param = 0;]]></code.init>
      <code.krate><![CDATA[// Exit early if not active
if (!inlet_active) return;

// Get param table
rootc::objectinstance_sketchy__params* param_table = &parent->objectinstance_sketchy__params_i;

// --- REDRAW MODE: Send all pages systematically ---
// Trigger redraw on rising edge
if ((inlet_redraw > 0) && !redraw_active) {
    redraw_active = 1;
    redraw_page = 0;
    redraw_param = 0;
}

// Clear redraw on falling edge (after completion)
if (!(inlet_redraw > 0)) {
    redraw_active = 0;
}

// If redraw is active, send parameters throttled across all pages
if (redraw_active) {
    // Send 2 parameters per k-rate cycle during redraw (throttled but reasonable)
    for (int i = 0; i < 2; i++) {
        if (redraw_page >= attr_maxpages) {
            // Finished all pages
            redraw_active = 0;
            break;
        }
        
        if (redraw_param >= attr_maxparams) {
            // Move to next page
            redraw_page++;
            redraw_param = 0;
            if (redraw_page >= attr_maxpages) {
                redraw_active = 0;
                break;
            }
        }
        
        // Resolve duplicate reference if this is a duplicate parameter
        int target_page, target_dial;
        resolve_duplicate_for_midi(redraw_page, redraw_param, &target_page, &target_dial);
        
        // Get value from param table (use target location for duplicates)
        int32_t value = param_table->array[target_page][target_dial];
        uint8_t midiValue = paramValueToMidiCC(value);
        
        // Calculate CC number based on target page/dial (original for duplicates)
        // This ensures duplicates send the CC for the parameter they're duplicating
        uint8_t ccNumber = (uint8_t)(inlet_startcc + target_dial + (target_page * attr_maxparams));
        
        // Send if valid CC and buffer has space
        if (ccNumber <= 127 && sdGetTimeout(&SD2, TIME_IMMEDIATE) == MSG_TIMEOUT) {
            SendMidi3(MIDI_CONTROL_CHANGE + (attr_channel - 1), ccNumber, midiValue);
        }
        
        redraw_param++;
    }
    
    // During redraw, skip normal scanning
    return;
}

// --- NORMAL MODE: Scan current page only ---
int8_t current_page = inlet_page;
if (current_page < 0) current_page = 0;

// Page changed - reset tracking for new page
if (current_page != last_page) {
    for (int i = 0; i < attr_maxparams; i++) {
        prev[i] = 0x7FFFFFFF; // Force resend all on page change
        ntrig[i] = 0;
    }
    last_page = current_page;
    scan_index = 0;
}

// IMPROVED THROTTLING: Scan 2 parameters per k-rate cycle
// This gives much better responsiveness while still preventing buffer overflow
// At 3kHz k-rate, this allows 6000 param updates/sec across 8 params = 750 updates/param/sec
for (int scan_count = 0; scan_count < 2; scan_count++) {
    if (scan_index >= attr_maxparams) {
        scan_index = 0;
    }
    
    // Resolve duplicate reference if this is a duplicate parameter
    int target_page, target_dial;
    bool is_duplicate = resolve_duplicate_for_midi(current_page, scan_index, &target_page, &target_dial);
    
    // Get current value from param table (use target location for duplicates)
    int32_t current_value = param_table->array[target_page][target_dial];
    
    // Check if value changed and not already triggered
    if ((current_value != prev[scan_index]) && !ntrig[scan_index]) {
        // Convert to MIDI CC range
        uint8_t midiValue = paramValueToMidiCC(current_value);
        
        // Calculate CC number based on target page/dial (original for duplicates)
        // This ensures duplicates send the CC for the parameter they're duplicating
        uint8_t ccNumber = (uint8_t)(inlet_startcc + target_dial + (target_page * attr_maxparams));
        
        // Only send if CC number is valid and buffer has space
        if (ccNumber <= 127 && sdGetTimeout(&SD2, TIME_IMMEDIATE) == MSG_TIMEOUT) {
            SendMidi3(MIDI_CONTROL_CHANGE + (attr_channel - 1), ccNumber, midiValue);
            prev[scan_index] = current_value;
            ntrig[scan_index] = 1;
        }
        // If buffer full, don't update prev - will retry next cycle
    }
    
    // Clear trigger when value stabilizes
    if (current_value == prev[scan_index]) {
        ntrig[scan_index] = 0;
    }
    
    scan_index++;
}]]></code.krate>
   </obj.normal>
</objdefs>

