<objdefs appVersion="1.0.12">
   <obj.normal id="8encoder_modes" uuid="e88edb94-5213-4ebf-82cc-37d68e461e7d">
      <sDescription>8 rotary encoders with acceleration, table storage, and configurable modes per encoder.</sDescription>
      <author>Gavin / Enhanced</author>
      <license>BSD</license>
      <helpPatch>logic.axh</helpPatch>
      <inlets>
         <bool32.rising name="trig1"/>
         <bool32.rising name="dir1"/>
         <bool32.rising name="trig2"/>
         <bool32.rising name="dir2"/>
         <bool32.rising name="trig3"/>
         <bool32.rising name="dir3"/>
         <bool32.rising name="trig4"/>
         <bool32.rising name="dir4"/>
         <bool32.rising name="trig5"/>
         <bool32.rising name="dir5"/>
         <bool32.rising name="trig6"/>
         <bool32.rising name="dir6"/>
         <bool32.rising name="trig7"/>
         <bool32.rising name="dir7"/>
         <bool32.rising name="trig8"/>
         <bool32.rising name="dir8"/>
         <int32 name="a"/>
      </inlets>
      <outlets>
         <frac32 name="o1"/>
         <frac32 name="o2"/>
         <frac32 name="o3"/>
         <frac32 name="o4"/>
         <frac32 name="o5"/>
         <frac32 name="o6"/>
         <frac32 name="o7"/>
         <frac32 name="o8"/>
         <int32 name="debug_int_val"/>
         <int32 name="debug_table_val"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <spinner name="acceltime" MinValue="1" MaxValue="1000" DefaultValue="0"/>
         <spinner name="accelmultiplier" MinValue="1" MaxValue="10" DefaultValue="0"/>
         <objref name="table"/>
      </attribs>
      <code.declaration><![CDATA[// Encoder data
float encoderPos[8];
int accel[8];
uint32_t lastTrigTime[8];
int lastTrigState[8];
int lastA = -1;
uint32_t timeCounter = 0;

// Mode constants
#define MODE_FRAC_PLUS    0  // 0.0 to 1.0, positive only
#define MODE_INT_PLUS     1  // min to max, positive only  
#define MODE_INT_BIPOLAR  2  // min to max, bipolar

// Mode configuration for encoders (8 encoders x multiple layers)
// Layer 0: encoders 0-7, Layer 1: encoders 8-15, etc.
const int8_t encoderModes[64] = {
    // Layer 0 (encoders 0-7)
    0, 0, 0, 1, 0, 0, 0, 1,
    // Layer 1 (encoders 8-15) 
    0, 1, 1, 0, 2, 0, 1, 0,
    // Layer 2 (encoders 16-23)
    1, 1, 0, 0, 1, 2, 0, 1,
    // Layer 3 (encoders 24-31)
    0, 0, 0, 1, 1, 1, 2, 2,
    // Layer 4 (encoders 32-39)
    0, 0, 0, 0, 0, 0, 0, 0,
    // Layer 5 (encoders 40-47)
    0, 0, 0, 0, 0, 0, 0, 0,
    // Layer 6 (encoders 48-55)
    0, 0, 0, 0, 0, 0, 0, 0,
    // Layer 7 (encoders 56-63)
    0, 0, 0, 0, 0, 0, 0, 0
};

// Min values for integer modes (8 encoders x multiple layers)
// NOTE: Large integer ranges require appropriate table bit depth:
// 8-bit table: ~100 steps max, 16-bit table: ~30k steps max, 32-bit table: ~2M+ steps max
const int16_t intMin[64] = {
    // Layer 0
    0, 0, 0, 0, 0, 0, 0, 0,
    // Layer 1
    0, 0, 0, 0, -32, 0, 1, 0,
    // Layer 2
    0, 0, 0, 0, 0, -100, 0, 0,
    // Layer 3
    0, 0, 0, 0, 0, 0, -50, -25,
    // Layer 4
    0, 0, 0, 0, 0, 0, 0, 0,
    // Layer 5
    0, 0, 0, 0, 0, 0, 0, 0,
    // Layer 6
    0, 0, 0, 0, 0, 0, 0, 0,
    // Layer 7
    0, 0, 0, 0, 0, 0, 0, 0
};

// Max values for integer modes (8 encoders x multiple layers)
const int16_t intMax[64] = {
    // Layer 0
    127, 127, 127, 63, 127, 127, 100, 999,
    // Layer 1
    127, 64, 32, 127, 31, 127, 10, 127,
    // Layer 2
    50, 200, 127, 127, 255, 99, 127, 8,
    // Layer 3
    127, 127, 127, 20, 15, 7, 49, 24,
    // Layer 4
    127, 127, 127, 127, 127, 127, 127, 127,
    // Layer 5
    127, 127, 127, 127, 127, 127, 127, 127,
    // Layer 6
    127, 127, 127, 127, 127, 127, 127, 127,
    // Layer 7
    127, 127, 127, 127, 127, 127, 127, 127
};

// Current integer values (for int modes)
int intValues[8];

// Helper functions
float applyModeConstraints(float value, int mode, int encoderIndex) {
    switch(mode) {
        case MODE_FRAC_PLUS:
            if(value < 0.0f) return 0.0f;
            if(value > 1.0f) return 1.0f;
            return value;
            
        case MODE_INT_PLUS:
        case MODE_INT_BIPOLAR:
            // For integer modes, we work with the intValues array
            // and convert to/from float for table storage
            return value; // Pass through, actual clamping done on intValues
            
        default:
            return value;
    }
}

void updateIntValue(int encoderIndex, int direction, int layer) {
    int arrayIndex = layer * 8 + encoderIndex;
    int minVal = intMin[arrayIndex];
    int maxVal = intMax[arrayIndex];
    
    // Simple increment/decrement - ignore any table data for now
    if (direction == 0) {
        intValues[encoderIndex]--;
    } else {
        intValues[encoderIndex]++;
    }
    
    // Clamp to range
    if (intValues[encoderIndex] < minVal) intValues[encoderIndex] = minVal;
    if (intValues[encoderIndex] > maxVal) intValues[encoderIndex] = maxVal;
}

void loadIntValue(int encoderIndex, int layer) {
    int arrayIndex = layer * 8 + encoderIndex;
    int minVal = intMin[arrayIndex];
    int maxVal = intMax[arrayIndex];
    
    // Load integer directly from table
    int index = layer * 8 + encoderIndex;
    if (index < attr_table.LENGTH) {
        intValues[encoderIndex] = attr_table.array[index];
    } else {
        intValues[encoderIndex] = minVal; // Default to minimum if out of bounds
    }
    
    // Clamp to range
    if (intValues[encoderIndex] < minVal) intValues[encoderIndex] = minVal;
    if (intValues[encoderIndex] > maxVal) intValues[encoderIndex] = maxVal;
}]]></code.declaration>
      <code.init><![CDATA[
for (int i = 0; i < 8; i++) {
    encoderPos[i] = 0.0f;
    accel[i] = 1;
    lastTrigTime[i] = 0;
    lastTrigState[i] = 0;
    intValues[i] = 0; // Initialize to 0, will be set properly when layer loads
}
lastA = -1;
timeCounter = 0;

// Clear entire table first to remove any old fixed-point data
for (int i = 0; i < attr_table.LENGTH; i++) {
    attr_table.array[i] = 0;
}

// Initialize table positions for integer modes to their minimum values
for (int layer = 0; layer < 8; layer++) {
    for (int enc = 0; enc < 8; enc++) {
        int arrayIndex = layer * 8 + enc;
        int tableIndex = layer * 8 + enc;
        if (tableIndex < attr_table.LENGTH && (encoderModes[arrayIndex] == MODE_INT_PLUS || encoderModes[arrayIndex] == MODE_INT_BIPOLAR)) {
            attr_table.array[tableIndex] = intMin[arrayIndex];
        }
    }
}
]]></code.init>
      <code.krate><![CDATA[timeCounter++;

// Calculate current layer and its base offset once
int layer = inlet_a;
int layer_offset = layer * 8; 

// Load from table when 'a' (layer selector) changes
if (inlet_a != lastA && layer >= 0 && layer < 8) { // Max 8 layers (0-7)
    for (int i = 0; i < 8; i++) { // 8 encoders
        int arrayIndex = layer_offset + i;
        
        // Bounds check for encoderModes array (max index 63 for 8 layers * 8 encoders)
        if (arrayIndex >= 64) continue; 

        int currentMode = encoderModes[arrayIndex];
        
        if (currentMode == MODE_INT_PLUS || currentMode == MODE_INT_BIPOLAR) {
            loadIntValue(i, layer); // loadIntValue internally recalculates layer*8, which is fine for its scope
        } else {
            // Fractional modes
            int table_idx = layer_offset + i;
            if (table_idx < attr_table.LENGTH) {
                int raw = attr_table.array[table_idx];
                encoderPos[i] = (float)raw / 1000.0f; 
                encoderPos[i] = applyModeConstraints(encoderPos[i], currentMode, i);
            }
        }
    }
    lastA = inlet_a;
}

// Process encoder inputs
bool trig[8] = {inlet_trig1, inlet_trig2, inlet_trig3, inlet_trig4, 
                inlet_trig5, inlet_trig6, inlet_trig7, inlet_trig8};
bool dir[8]  = {inlet_dir1,  inlet_dir2,  inlet_dir3,  inlet_dir4,  
                inlet_dir5,  inlet_dir6,  inlet_dir7,  inlet_dir8};

for (int i = 0; i < 8; i++) {
    bool edge = (trig[i] == 1) && (lastTrigState[i] == 0);
    lastTrigState[i] = trig[i];

    if (edge) {
        int arrayIndex = layer_offset + i;
        
        // Bounds check for encoderModes array
        if (arrayIndex >= 64) continue;

        int currentMode = encoderModes[arrayIndex];
        
        if (currentMode == MODE_INT_PLUS || currentMode == MODE_INT_BIPOLAR) {
            updateIntValue(i, dir[i], layer); // updateIntValue uses layer directly
            int table_idx = layer_offset + i;
            if (table_idx < attr_table.LENGTH) {
                attr_table.array[table_idx] = intValues[i];
            }
        } else {
            // Fractional mode
            uint32_t diff = timeCounter - lastTrigTime[i];
            if (diff < attr_acceltime) {
                accel[i]++;
                if (accel[i] > attr_accelmultiplier) accel[i] = attr_accelmultiplier;
            } else {
                accel[i] = 1;
            }
            float inc = 0.0078125f * accel[i]; // 1/128
            if (dir[i] == 0) {
                encoderPos[i] -= inc;
            } else {
                encoderPos[i] += inc;
            }
            if (encoderPos[i] < 0.0f) encoderPos[i] = 0.0f;
            if (encoderPos[i] > 1.0f) encoderPos[i] = 1.0f;
            
            int table_idx = layer_offset + i;
            if (table_idx < attr_table.LENGTH) {
                attr_table.array[table_idx] = (int)(encoderPos[i] * 1000.0f); 
            }
        }
        lastTrigTime[i] = timeCounter;
    }
}

// Output values - only for fractional modes, integer modes output 0
// Ensure layer_offset + k is within encoderModes bounds (0-63)
outlet_o1 = (layer_offset + 0 < 64 && (encoderModes[layer_offset + 0] == MODE_INT_PLUS || encoderModes[layer_offset + 0] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[0] * (float)(1 << 27));
outlet_o2 = (layer_offset + 1 < 64 && (encoderModes[layer_offset + 1] == MODE_INT_PLUS || encoderModes[layer_offset + 1] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[1] * (float)(1 << 27));
outlet_o3 = (layer_offset + 2 < 64 && (encoderModes[layer_offset + 2] == MODE_INT_PLUS || encoderModes[layer_offset + 2] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[2] * (float)(1 << 27));
outlet_o4 = (layer_offset + 3 < 64 && (encoderModes[layer_offset + 3] == MODE_INT_PLUS || encoderModes[layer_offset + 3] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[3] * (float)(1 << 27));
outlet_o5 = (layer_offset + 4 < 64 && (encoderModes[layer_offset + 4] == MODE_INT_PLUS || encoderModes[layer_offset + 4] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[4] * (float)(1 << 27));
outlet_o6 = (layer_offset + 5 < 64 && (encoderModes[layer_offset + 5] == MODE_INT_PLUS || encoderModes[layer_offset + 5] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[5] * (float)(1 << 27));
outlet_o7 = (layer_offset + 6 < 64 && (encoderModes[layer_offset + 6] == MODE_INT_PLUS || encoderModes[layer_offset + 6] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[6] * (float)(1 << 27));
outlet_o8 = (layer_offset + 7 < 64 && (encoderModes[layer_offset + 7] == MODE_INT_PLUS || encoderModes[layer_offset + 7] == MODE_INT_BIPOLAR)) ? 0 : (int)(encoderPos[7] * (float)(1 << 27));]]></code.krate>
   </obj.normal>
</objdefs>