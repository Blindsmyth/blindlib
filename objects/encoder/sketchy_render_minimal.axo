<objdefs appVersion="1.0.12">
   <obj.normal id="sketchy_render" uuid="2a3b4c5d-6e7f-8a9b-0c1d-2e3f4a5b6c7d">
      <sDescription>Minimal OLED renderer for encoder displays - optimized for memory usage</sDescription>
      <author>AI Assistant</author>
      <license>BSD</license>
      <helpPatch>logic.axh</helpPatch>
      <inlets>
         <int32.positive name="page" description="set current page"/>
         <int32.positive name="layout" description="set layout page (always visible)"/>
         <bool32.rising name="print" description="Will log the state of the object table to axoloti window"/>
      </inlets>
      <outlets>
         <int32.positive name="sw" description="screen width"/>
         <int32.positive name="sh" description="screen height"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <combo name="type">
            <MenuEntries>
               <string>SSD1306</string>
               <string>SH1106</string>
            </MenuEntries>
            <CEntries>
               <string>1306</string>
               <string>1106</string>
            </CEntries>
         </combo>
         <combo name="I2CADDR">
            <MenuEntries>
               <string>0x3C</string>
               <string>0x3D</string>
            </MenuEntries>
            <CEntries>
               <string>0x3C</string>
               <string>0x3D</string>
            </CEntries>
         </combo>
      </attribs>
      <includes>
         <include>math.h</include>
      </includes>
      <depends>
         <depend>SD1</depend>
         <depend>I2CD1</depend>
         <depend>SPID1</depend>
      </depends>
      <code.declaration><![CDATA[// Essential display structures - simplified versions
typedef struct {
    uint8_t page;
    uint8_t param;
    bool is_bipolar;
    uint8_t x;
    uint8_t y;
    uint8_t width;
    uint8_t height;
    const char* label;
    bool show_value;
    int32_t default_value;
} dial_t;

typedef struct {
    uint8_t page;
    uint8_t param;
    uint8_t x;
    uint8_t y;
    uint8_t width;
    uint8_t height;
    const char* label;
} intdisplay_t;

typedef struct {
    uint8_t page;
    uint8_t param;
    uint8_t x;
    uint8_t y;
    uint8_t width;
    uint8_t height;
    bool is_int;
    const char* label;
} select_t;

// Display constants
enum SSD1306 {
    LCDWIDTH            = 128,
    LCDHEIGHT           = 64,
    SETCONTRAST         = 0x81,
    DISPLAYON           = 0xAF,
    DISPLAYOFF          = 0xAE,
    DISPLAYALLON_RESUME = 0xA4,
    NORMALDISPLAY       = 0xA6,
    DEACTIVATE_SCROLL   = 0x2E,
    MEMORYMODE          = 0x20,
    COLUMNADDR          = 0x21,
    PAGEADDR            = 0x22,
    SETSTARTLINE_0      = 0x40,
    SEGREMAP            = 0xA0,
    SETMULTIPLEX        = 0xA8,
    COMSCANDEC          = 0xC8,
    SETDISPLAYOFFSET    = 0xD3,
    SETCOMPINS          = 0xDA,
    SETDISPLAYCLOCKDIV  = 0xD5,
    SETPRECHARGE        = 0xD9,
    SETVCOMDETECT       = 0xDB,
    CHARGEPUMP          = 0x8D,
    EXTERNALVCC         = 0x1,
    SWITCHCAPVCC        = 0x2,
};

// Display buffer - moved to SDRAM to save SRAM
uint8_t *display_buffer;
uint8_t *txbuf;
uint8_t *rxbuf;

uint16_t page;
uint16_t layout;
bool pprint;

// Reference to font object
rootc::instancesketchy__font* font;

// Basic OLED communication
void cmd(uint8_t c) {
    txbuf[0] = 0;
    txbuf[1] = c;
    i2cMasterTransmitTimeout(&I2CD1, attr_I2CADDR, txbuf, 2, rxbuf, 0, 30);
}

void clear_display() {
    for (int page = 0; page < 8; page++) {
        for (int i = 0; i < LCDWIDTH; i++) {
            display_buffer[page * LCDWIDTH + i] = 0;
        }
    }
}

void sendPage(int page_num) {
    cmd(COLUMNADDR); cmd(0); cmd(127);
    cmd(PAGEADDR); cmd(page_num); cmd(page_num);

    if (attr_type == 1106) {
        cmd(0xB0 + page_num);
        cmd(2 & 0xf);
        cmd(0x10 | (2 >> 4));
    }

    txbuf[0] = 0x40;
    memcpy(txbuf + 1, display_buffer + (page_num * LCDWIDTH), LCDWIDTH);
    i2cMasterTransmitTimeout(&I2CD1, attr_I2CADDR, txbuf, 129, rxbuf, 0, 30);
}

void oled_init() {
    cmd(DISPLAYOFF);
    cmd(SETDISPLAYCLOCKDIV); cmd(0x80);
    cmd(SETMULTIPLEX); cmd(LCDHEIGHT - 1);
    cmd(SETDISPLAYOFFSET); cmd(attr_type == 1306 ? 0x00 : 0x01);
    cmd(SETSTARTLINE_0);
    cmd(CHARGEPUMP); cmd(0x14);
    cmd(MEMORYMODE); cmd(0x00);
    cmd(SEGREMAP | 0x1);
    cmd(COMSCANDEC);
    cmd(SETCOMPINS); cmd(0x12);
    cmd(SETCONTRAST); cmd(0xCF);
    cmd(SETPRECHARGE); cmd(0xF1);
    cmd(SETVCOMDETECT); cmd(0x40);
    cmd(DISPLAYALLON_RESUME);
    cmd(NORMALDISPLAY);
    cmd(DEACTIVATE_SCROLL);
    cmd(DISPLAYON);
}

// Simple pixel drawing
void set_pixel(int x, int y, bool on) {
    if (x < 0 || x >= LCDWIDTH || y < 0 || y >= LCDHEIGHT) return;
    
    int page = y / 8;
    int bit = y % 8;
    int index = page * LCDWIDTH + x;
    
    if (on) {
        display_buffer[index] |= (1 << bit);
    } else {
        display_buffer[index] &= ~(1 << bit);
    }
}

// Simple line drawing
void draw_line(int x0, int y0, int x1, int y1) {
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx - dy;
    
    while (true) {
        set_pixel(x0, y0, true);
        
        if (x0 == x1 && y0 == y1) break;
        
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}

// Simple rectangle
void draw_rect(int x, int y, int w, int h) {
    draw_line(x, y, x + w - 1, y);           // Top
    draw_line(x, y + h - 1, x + w - 1, y + h - 1); // Bottom
    draw_line(x, y, x, y + h - 1);           // Left
    draw_line(x + w - 1, y, x + w - 1, y + h - 1); // Right
}

// Simple circle (for dial indicators)
void draw_circle(int cx, int cy, int radius) {
    int x = radius;
    int y = 0;
    int err = 0;
    
    while (x >= y) {
        set_pixel(cx + x, cy + y, true);
        set_pixel(cx + y, cy + x, true);
        set_pixel(cx - y, cy + x, true);
        set_pixel(cx - x, cy + y, true);
        set_pixel(cx - x, cy - y, true);
        set_pixel(cx - y, cy - x, true);
        set_pixel(cx + y, cy - x, true);
        set_pixel(cx + x, cy - y, true);
        
        if (err <= 0) {
            y += 1;
            err += 2*y + 1;
        }
        if (err > 0) {
            x -= 1;
            err -= 2*x + 1;
        }
    }
}

// Font rendering using sketchy font object
void draw_char(int x, int y, char c) {
    if (c < ' ' || c > '~') return;  // Only printable ASCII
    if (!font) return;  // Safety check
    
    // Get character data from font object
    int index = (c - ' ') * font->width;
    
    for (int col = 0; col < font->width; col++) {
        uint8_t byte = font->data[index + col];
        for (int row = 0; row < font->height; row++) {
            if (byte & (1 << row)) {
                set_pixel(x + col, y + row, true);
            }
        }
    }
}

void draw_text(int x, int y, const char* text) {
    if (!text || !font) return;
    
    int pos_x = x;
    while (*text && pos_x < LCDWIDTH - font->width) {
        draw_char(pos_x, y, *text);
        pos_x += font->width + 1;  // Character width + 1 pixel spacing
        text++;
    }
}

// Simplified display functions - minimal but compatible
void dial_init(dial_t* dial) {
    // Just store the dial info - actual rendering happens in update
}

void dial_update(dial_t* dial) {
    if (!dial) return;
    
    // Get current value from param table
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
    int32_t value = param_table->array[dial->page][dial->param];
    
    // Draw incomplete dial outline (leave bottom gap for text)
    int cx = dial->x + dial->width/2;
    int cy = dial->y + dial->height/2 - 2;  // Shift entire dial up by 2 pixels
    int radius = dial->width/2 - 2;  // Back to original size
    
    // Draw arc from 135° to 45° (going clockwise), leaving bottom gap (45° to 135°) for text
    for (int angle_deg = 135; angle_deg != 45; ) {
        float angle_rad = angle_deg * 3.14159f / 180.0f;
        int x = cx + (int)(cosf(angle_rad) * radius);
        int y = cy + (int)(sinf(angle_rad) * radius);
        set_pixel(x, y, true);
        
        angle_deg += 2;
        if (angle_deg >= 360) angle_deg -= 360;  // Wrap around
        if (angle_deg == 45) break;  // Stop before the gap
    }
    
    // Draw indicator line based on value
    float normalized = (float)value / (float)(1 << 27);
    if (normalized < 0.0f) normalized = 0.0f;
    if (normalized > 1.0f) normalized = 1.0f;
    
    // Map to 270° range: 135° to 45° (going clockwise, avoiding bottom gap)
    // This maps 0.0 -> 135°, 1.0 -> 45° (270° sweep clockwise)
    float angle_deg = 135.0f + (normalized * 270.0f);
    if (angle_deg >= 360.0f) angle_deg -= 360.0f;  // Wrap around
    float angle = angle_deg * 3.14159f / 180.0f;
    int indicator_radius = dial->width/2 - 2;  // Touch the circle edge
    
    // Use standard math functions
    float cos_val = cosf(angle);
    float sin_val = sinf(angle);
    int end_x = cx + (int)(cos_val * indicator_radius);
    int end_y = cy + (int)(sin_val * indicator_radius);
    
    draw_line(cx, cy, end_x, end_y);
    
    // Draw label in the bottom gap area (centered below the dial)
    if (dial->label && strlen(dial->label) > 0) {
        int text_width = strlen(dial->label) * (font ? font->width + 1 : 6);
        int text_x = dial->x + (dial->width - text_width) / 2;
        int text_y = dial->y + dial->height - (font ? font->height : 8) + 2;  // Shift up by 2 pixels to match dial
        draw_text(text_x, text_y, dial->label);
    }
}

void intdisplay_init(intdisplay_t* display) {
    // Just store the display info
}

void intdisplay_update(intdisplay_t* display) {
    if (!display) return;
    
    // Get current value from param table
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
    int32_t value = param_table->array[display->page][display->param];
    
    // Draw simple rectangle for integer display
    draw_rect(display->x, display->y, display->width, display->height);
    
    // Draw label if present
    if (display->label && strlen(display->label) > 0) {
        draw_text(display->x, display->y - 8, display->label);
    }
    
    // Draw value (simplified - just show something)
    draw_text(display->x + 2, display->y + 2, "INT");
}

void select_init(select_t* select) {
    // Just store the select info
}

void select_update(select_t* select) {
    if (!select) return;
    
    // Get current value from param table
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
    int32_t value = param_table->array[select->page][select->param];
    
    // Draw simple rectangle for selector
    draw_rect(select->x, select->y, select->width, select->height);
    
    // Draw label if present (this contains the options list)
    if (select->label && strlen(select->label) > 0) {
        draw_text(select->x + 2, select->y + 2, "SEL");
    }
}

// Compatibility functions for sketchy_dials and other objects
int count_tokens(const char* str, char delimiter) {
    if (!str) return 0;
    int count = 1;
    while (*str) {
        if (*str == delimiter) count++;
        str++;
    }
    return count;
}

// Overloaded version for comma-separated strings (for pager compatibility)
int count_tokens(const char* str) {
    return count_tokens(str, ',');
}

void get_token_at_index(const char* str, char delimiter, int index, char* output, int max_len) {
    if (!str || !output || max_len <= 0) return;
    
    int current_index = 0;
    const char* start = str;
    const char* end = str;
    
    // Find the token at the specified index
    while (*end && current_index < index) {
        if (*end == delimiter) {
            current_index++;
            start = end + 1;
        }
        end++;
    }
    
    // Find the end of the current token
    while (*end && *end != delimiter) {
        end++;
    }
    
    // Copy the token
    int len = end - start;
    if (len >= max_len) len = max_len - 1;
    strncpy(output, start, len);
    output[len] = '\0';
}

// Overloaded version for pager compatibility (returns pointer to static buffer)
const char* get_token_at_index(const char* str, int index) {
    static char token_buffer[32];
    get_token_at_index(str, ',', index, token_buffer, sizeof(token_buffer));
    return token_buffer;
}

int getCurrentPage() {
    return page;
}

// Render thread - simplified
msg_t ThreadX2() {
    chRegSetThreadName("sketchy_render");
    
    while (!chThdShouldTerminate()) {
        clear_display();
        
        // Minimal rendering - just update display
        for (uint8_t i = 0; i < 8; i++) {
            sendPage(i);
        }
        
        chThdSleepMilliseconds(32); // ~30 FPS
    }
    
    chThdExit((msg_t)0);
}

static msg_t ThreadX(void *arg) {
    ((attr_parent *)arg)->ThreadX2();
}

WORKING_AREA(waThreadX, 512); // Reduced stack size
Thread *Thd;]]></code.declaration>
      <code.init><![CDATA[// Create SDRAM shadow arrays for display buffers
static uint8_t _display_buffer[8 * LCDWIDTH] __attribute__ ((section (".sdram")));
static uint8_t _txbuf[129] __attribute__ ((section (".sdram")));
static uint8_t _rxbuf[8] __attribute__ ((section (".sdram")));

display_buffer = &_display_buffer[0];
txbuf = &_txbuf[0];
rxbuf = &_rxbuf[0];

// Setup I2C pins
palSetPadMode(GPIOB, 8, PAL_MODE_ALTERNATE(4)|PAL_STM32_PUDR_PULLUP|PAL_STM32_OTYPE_OPENDRAIN);// SCL
palSetPadMode(GPIOB, 9, PAL_MODE_ALTERNATE(4)|PAL_STM32_PUDR_PULLUP|PAL_STM32_OTYPE_OPENDRAIN);// SDA
static const I2CConfig i2cfg = {
    OPMODE_I2C,
    400000,
    FAST_DUTY_CYCLE_2,
};
i2cStart(&I2CD1, &i2cfg);

// Initialize OLED
oled_init();
clear_display();

// Initialize variables
pprint = false;
page = 0;
layout = 0xFFFF;

// Get reference to font object
font = &parent->instancesketchy__font_i;

// Start render thread with reduced stack
Thd = chThdCreateStatic(waThreadX, sizeof(waThreadX), NORMALPRIO, ThreadX, (void *)this);]]></code.init>
      <code.dispose><![CDATA[if (Thd) {
    chThdTerminate(Thd);
    chThdWait(Thd);
}
i2cStop(&I2CD1);
palSetPadMode(GPIOB, 8, PAL_MODE_INPUT_ANALOG);
palSetPadMode(GPIOB, 9, PAL_MODE_INPUT_ANALOG);]]></code.dispose>
      <code.krate><![CDATA[if (inlet_print && !pprint) {
    pprint = true;
    // Simplified print functionality - just log that print was triggered
    LogTextMessage("sketchy_render_minimal: print triggered");
}

if (!inlet_print && pprint) {
    pprint = false;
}

if (page != inlet_page) {
    page = inlet_page;
}
if (layout != inlet_layout) {
    layout = inlet_layout;
}

outlet_sw = LCDWIDTH;
outlet_sh = LCDHEIGHT;]]></code.krate>
   </obj.normal>
</objdefs>