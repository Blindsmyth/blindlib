<objdefs appVersion="1.0.12">
   <obj.normal id="ldrive_musical" uuid="5224773f-18de-4231-8f92-b1f22bb95383">
      <sDescription>drives a phasor (saw-wave) for reading/writing data - musical pitch mapping</sDescription>
      <author>robert schirmer (modified for musical pitch mapping)</author>
      <license>BSD</license>
      <helpPatch>ldrive.axh</helpPatch>
      <inlets>
         <frac32.positive name="offset" description="offset inside the table"/>
         <frac32.positive name="range" description="length of the area to index,or loop end"/>
         <frac32.positive name="startpoint" description="position inside range on reset"/>
         <frac32.bipolar name="pitch" description="musical pitch input (-64 to +64)"/>
         <bool32.rising name="play" description="trigger playback"/>
      </inlets>
      <outlets>
         <frac32buffer.positive name="pos" description="relative position inside table"/>
         <int32 name="spos" description="playhead position inside range in samples"/>
         <int32 name="stotal" description="length of range in samples"/>
         <frac32.bipolar name="speed" description="total speed"/>
         <bool32 name="play" description="playback state"/>
      </outlets>
      <displays/>
      <params>
         <frac32.s.map name="pitch" description="musical pitch ,+ 64 normal speed forward, - 64 backward" noLabel="true">
            <DefaultValue v="0.0"/>
         </frac32.s.map>
      </params>
      <attribs>
         <objref name="table"/>
      </attribs>
      <includes/>
      <code.declaration><![CDATA[int32_t index;
uint8_t shift;

int ntrig;

int32_t t_speed;
int32_t re;
int32_t rs;

int32_t start;
int32_t loopstart;
int32_t lrange;

bool play;]]></code.declaration>
      <code.init><![CDATA[shift = (27-attr_table.LENGTHPOW);]]></code.init>
      <code.krate><![CDATA[//scale ranges up 8 times to achieve decent resolution for parameter speed
lrange = inlet_range << 3;
start = ___SMMUL(inlet_range,inlet_startpoint)<< 8;
re = (t_speed > 0 ) ? lrange - (4 << shift) : lrange;
rs = (t_speed > 0 ) ? start : start -  (4 << shift);

// Musical pitch mapping for ldrive phasor
int32_t total_pitch = inlet_pitch + param_pitch;

// Convert musical pitch to speed multiplier using exponential mapping
// 0 = normal speed (1x), 12 = 2x speed, -12 = 0.5x speed
// Use a simpler approach that works for phasor increments

// Base speed for normal playback (1x speed)
int32_t base_speed = 64;

// Calculate speed multiplier based on pitch
// Each semitone = 2^(1/12) ≈ 1.059 multiplier
// Each octave = 2x multiplier
int32_t speed_multiplier = base_speed;

if(total_pitch != 0) {
    // Convert pitch to semitones (assuming -64 to +64 range)
    // Normalize to get reasonable semitone values
    int32_t semitones = (total_pitch * 12) / 64;  // Scale to ±12 semitones
    
    // Clamp to reasonable range
    if(semitones > 24) semitones = 24;   // 2 octaves up
    if(semitones < -24) semitones = -24; // 2 octaves down
    
    if(semitones > 0) {
        // Positive semitones: increase speed
        // Use bit shifting for octaves and approximation for remaining semitones
        int32_t octaves = semitones / 12;
        int32_t remaining = semitones % 12;
        
        // Apply octave shifts
        if(octaves > 0) {
            speed_multiplier = speed_multiplier << octaves;
        }
        
        // Apply remaining semitone adjustment (approximate)
        if(remaining > 0) {
            // Simple approximation: each semitone adds about 6%
            speed_multiplier = (speed_multiplier * (12 + remaining)) / 12;
        }
        
    } else if(semitones < 0) {
        // Negative semitones: decrease speed
        int32_t abs_semitones = -semitones;
        int32_t octaves = abs_semitones / 12;
        int32_t remaining = abs_semitones % 12;
        
        // Apply octave shifts
        if(octaves > 0) {
            speed_multiplier = speed_multiplier >> octaves;
        }
        
        // Apply remaining semitone adjustment (approximate)
        if(remaining > 0) {
            // Simple approximation: each semitone subtracts about 6%
            speed_multiplier = (speed_multiplier * (12 - remaining)) / 12;
        }
        
        // Ensure minimum speed
        if(speed_multiplier < 1) speed_multiplier = 1;
    }
}

// Calculate t_speed using the musical speed multiplier
// Scale up for resolution and apply table length division
t_speed = ((speed_multiplier << 3) >> attr_table.LENGTHPOW);

if (inlet_play && (!ntrig)) {
    ntrig = 1;
    index = (t_speed < 0) ? lrange:start;
    play = 1; 
}  
else if (!(inlet_play > 0)) ntrig = 0;

if (!inlet_range) play = 0;

outlet_spos =  (((index >> 3) >> shift) > 0) ? ((index >> 3)>> shift) : 0;
outlet_stotal = inlet_range >> shift;
outlet_speed = total_pitch;  // Output the musical pitch value
outlet_play = play;]]></code.krate>
      <code.srate><![CDATA[if ((index > re)||(index < rs)) play = 0;

if (play){
    outlet_pos =  __USAT(((index >> 3) + inlet_offset),27);
    index += t_speed;
}
else outlet_pos = 1 << 27;]]></code.srate>
   </obj.normal>
</objdefs> 