<objdefs appVersion="1.0.12">
   <obj.normal id="8encoder_dials_fused" uuid="8e4f7b2a-9c5d-4e3f-8a1b-6f9e5d2c3b4a">
      <sDescription>8 rotary encoders with acceleration, table storage, configurable modes, and integrated dial/display system. Combines encoder input with visual feedback.</sDescription>
      <author>Fused by AI</author>
      <license>BSD</license>
      <helpPatch>logic.axh</helpPatch>
      <inlets>
         <bool32.rising name="trig1"/>
         <bool32.rising name="dir1"/>
         <bool32.rising name="trig2"/>
         <bool32.rising name="dir2"/>
         <bool32.rising name="trig3"/>
         <bool32.rising name="dir3"/>
         <bool32.rising name="trig4"/>
         <bool32.rising name="dir4"/>
         <bool32.rising name="trig5"/>
         <bool32.rising name="dir5"/>
         <bool32.rising name="trig6"/>
         <bool32.rising name="dir6"/>
         <bool32.rising name="trig7"/>
         <bool32.rising name="dir7"/>
         <bool32.rising name="trig8"/>
         <bool32.rising name="dir8"/>
         <int32 name="page"/>
      </inlets>
      <outlets>
         <frac32 name="o1"/>
         <frac32 name="o2"/>
         <frac32 name="o3"/>
         <frac32 name="o4"/>
         <frac32 name="o5"/>
         <frac32 name="o6"/>
         <frac32 name="o7"/>
         <frac32 name="o8"/>
         <int32 name="debugintval"/>
         <int32 name="debugtableval"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <spinner name="acceltime" MinValue="1" MaxValue="1000" DefaultValue="100"/>
         <spinner name="accelmultiplier" MinValue="1" MaxValue="10" DefaultValue="6"/>
         <spinner name="firstparam" MinValue="0" MaxValue="118" DefaultValue="0"/>
      </attribs>
      <includes/>
      <code.declaration><![CDATA[// Unified configuration structure for each encoder+dial
typedef struct {
    uint8_t mode;           // 0=frac unipolar, 1=frac bipolar, 2=int, 3=list
    uint8_t param;          // Parameter index
    bool show_value;        // Show/hide value (for fractional modes)
    const char* label;      // Label text
    const char* options;    // List options (for mode 3)
    float default_value;    // Default value (for fractional modes)
    int16_t int_min;        // Minimum value (for int/list modes)
    int16_t int_max;        // Maximum value (for int/list modes)
} encoder_dial_config_t;

// Configuration for 8 pages, 8 encoders each (64 total configurations)
const encoder_dial_config_t configs[8][8] = {
    // PAGE 0 - Oscillator controls
    {
        {1, 0, true,  "FIN", "", 0.0f, 0, 127},                           // Fine tune
        {1, 1, true,  "WAV", "", 0.0f, 0, 127},                           // Waveform
        {1, 2, true,  "PHS", "", 0.0f, 0, 127},                           // Phase
        {3, 3, false, "", "Sin,Tri,Saw,Sqr,Nse", 0.0f, 0, 4},            // Wave selector
        {0, 4, false, "DET", "", 0.0f, 0, 127},                           // Detune
        {0, 5, false, "SUB", "", 0.0f, 0, 127},                           // Sub osc
        {0, 6, false, "MIX", "", 0.0f, 0, 127},                           // Mix
        {2, 7, false, "OCT", "", 0.0f, -4, 4}                             // Octave
    },
    // PAGE 1 - Filter controls
    {
        {0, 0, true,  "CUT", "", 0.5f, 0, 127},                           // Cutoff
        {1, 1, true,  "RES", "", 0.0f, 0, 127},                           // Resonance
        {1, 2, false, "ENV", "", 0.0f, -64, 64},                          // Env amount
        {3, 3, false, "", "LP,HP,BP,BR", 0.0f, 0, 3},                     // Filter type
        {0, 4, false, "KBD", "", 0.0f, 0, 127},                           // Keyboard track
        {0, 5, false, "VEL", "", 0.0f, 0, 127},                           // Velocity
        {0, 6, false, "LFO", "", 0.0f, 0, 127},                           // LFO amount
        {2, 7, false, "DRV", "", 0.0f, 0, 100}                            // Drive
    },
    // PAGE 2 - Envelope controls
    {
        {0, 0, false, "ATK", "", 0.0f, 0, 127},                           // Attack
        {0, 1, false, "DEC", "", 0.0f, 0, 127},                           // Decay
        {0, 2, false, "SUS", "", 0.7f, 0, 127},                           // Sustain
        {0, 3, false, "REL", "", 0.0f, 0, 127},                           // Release
        {1, 4, false, "VEL", "", 0.0f, -100, 100},                        // Velocity
        {1, 5, false, "CRV", "", 0.0f, -50, 50},                          // Curve
        {0, 6, false, "TIM", "", 0.0f, 0, 127},                           // Time scale
        {3, 7, false, "", "Lin,Exp,Log", 0.0f, 0, 2}                      // Curve type
    },
    // PAGE 3 - LFO controls
    {
        {0, 0, true,  "RAT", "", 0.0f, 0, 127},                           // Rate
        {1, 1, false, "DEP", "", 0.0f, -127, 127},                        // Depth
        {1, 2, false, "PHS", "", 0.0f, -127, 127},                        // Phase
        {3, 3, false, "", "Sin,Tri,Saw,Sqr,S&H", 0.0f, 0, 4},            // LFO shape
        {0, 4, false, "SYN", "", 0.0f, 0, 127},                           // Sync
        {0, 5, false, "DEL", "", 0.0f, 0, 127},                           // Delay
        {0, 6, false, "FAD", "", 0.0f, 0, 127},                           // Fade in
        {2, 7, false, "DIV", "", 0.0f, 1, 32}                             // Division
    },
    // PAGE 4 - Effects controls
    {
        {0, 0, false, "REV", "", 0.0f, 0, 127},                           // Reverb
        {0, 1, false, "DEL", "", 0.0f, 0, 127},                           // Delay
        {0, 2, false, "CHO", "", 0.0f, 0, 127},                           // Chorus
        {0, 3, false, "DIS", "", 0.0f, 0, 127},                           // Distortion
        {1, 4, false, "TIM", "", 0.0f, -64, 64},                          // Delay time
        {1, 5, false, "FBK", "", 0.0f, -100, 100},                        // Feedback
        {0, 6, false, "MIX", "", 0.0f, 0, 127},                           // Wet/Dry
        {3, 7, false, "", "Off,Hall,Room,Plate", 0.0f, 0, 3}              // Reverb type
    },
    // PAGE 5 - Sequencer controls
    {
        {2, 0, true,  "STP", "", 16.0f, 1, 64},                           // Steps
        {0, 1, true,  "SPD", "", 0.5f, 0, 127},                           // Speed
        {1, 2, false, "SWG", "", 0.0f, -50, 50},                          // Swing
        {3, 3, false, "", "Fwd,Rev,P-P,Rnd", 0.0f, 0, 3},                // Direction
        {0, 4, false, "GAT", "", 0.8f, 0, 127},                           // Gate
        {1, 5, false, "ACC", "", 0.0f, -127, 127},                        // Accent
        {0, 6, false, "SLD", "", 0.0f, 0, 127},                           // Slide
        {2, 7, false, "RST", "", 0.0f, 0, 1}                              // Reset
    },
    // PAGE 6 - Modulation controls
    {
        {1, 0, false, "M1A", "", 0.0f, -127, 127},                        // Mod 1 amount
        {1, 1, false, "M2A", "", 0.0f, -127, 127},                        // Mod 2 amount
        {1, 2, false, "M3A", "", 0.0f, -127, 127},                        // Mod 3 amount
        {3, 3, false, "", "LFO,ENV,VEL,RND", 0.0f, 0, 3},                // Mod source
        {3, 4, false, "", "Cut,Res,Amp,Pan", 0.0f, 0, 3},                // Mod dest 1
        {3, 5, false, "", "Pit,Phs,PWM,FM", 0.0f, 0, 3},                 // Mod dest 2
        {0, 6, false, "ATN", "", 0.0f, 0, 127},                           // Attenuator
        {2, 7, false, "LAG", "", 0.0f, 0, 100}                            // Lag
    },
    // PAGE 7 - Global controls
    {
        {0, 0, true,  "VOL", "", 0.8f, 0, 127},                           // Volume
        {1, 1, false, "PAN", "", 0.0f, -64, 64},                          // Pan
        {0, 2, false, "TUN", "", 0.0f, 0, 127},                           // Tune
        {2, 3, true,  "TRS", "", 0.0f, -24, 24},                          // Transpose
        {0, 4, false, "VEL", "", 0.8f, 0, 127},                           // Velocity
        {0, 5, false, "POR", "", 0.0f, 0, 127},                           // Portamento
        {2, 6, false, "CHN", "", 1.0f, 1, 16},                            // MIDI channel
        {3, 7, false, "", "Poly,Mono,Leg", 0.0f, 0, 2}                    // Play mode
    }
};

// Encoder data
float encoderPos[8];
int accel[8];
uint32_t lastTrigTime[8];
int lastTrigState[8];
int lastPage = -1;
uint32_t timeCounter = 0;
int intValues[8];

// Mode constants
#define MODE_FRAC_UNIPOLAR 0  // 0.0 to 1.0, positive only
#define MODE_FRAC_BIPOLAR  1  // -1.0 to 1.0, bipolar
#define MODE_INT           2  // min to max, integer
#define MODE_LIST          3  // selector mode

// Display structures for each type - 64 total (8 pages x 8 dials)
rootc::instancesketchy__render::dial_t dials[64];
rootc::instancesketchy__render::intdisplay_t intdisplays[64];
rootc::instancesketchy__render::select_t selects[64];

// Fixed layout positions
const uint8_t DIAL_WIDTH = 24;
const uint8_t DIAL_HEIGHT = 24;
const uint8_t ROW1_Y = 13;
const uint8_t ROW2_Y = 39;
const uint8_t COL_X[4] = {26, 52, 78, 104};

// Helper functions
float applyModeConstraints(float value, int mode, int encoderIndex) {
    switch(mode) {
        case MODE_FRAC_UNIPOLAR:
            if(value < 0.0f) return 0.0f;
            if(value > 1.0f) return 1.0f;
            return value;
        case MODE_FRAC_BIPOLAR:
            if(value < -1.0f) return -1.0f;
            if(value > 1.0f) return 1.0f;
            return value;
        case MODE_INT:
        case MODE_LIST:
            return value;
        default:
            return value;
    }
}

void updateIntValue(int encoderIndex, int direction, int page) {
    const encoder_dial_config_t* config = &configs[page][encoderIndex];
    int minVal = config->int_min;
    int maxVal = config->int_max;
    
    if (direction == 0) {
        intValues[encoderIndex]--;
    } else {
        intValues[encoderIndex]++;
    }
    
    if (intValues[encoderIndex] < minVal) intValues[encoderIndex] = minVal;
    if (intValues[encoderIndex] > maxVal) intValues[encoderIndex] = maxVal;
}

void loadIntValue(int encoderIndex, int page) {
    const encoder_dial_config_t* config = &configs[page][encoderIndex];
    int minVal = config->int_min;
    int maxVal = config->int_max;
    
    // Load value from sketchy param table
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
    int firstparam = attr_firstparam;
    
    // Load the actual value from the table using the page parameter
    intValues[encoderIndex] = param_table->array[page][firstparam + encoderIndex];
    
    // Clamp to range
    if (intValues[encoderIndex] < minVal) intValues[encoderIndex] = minVal;
    if (intValues[encoderIndex] > maxVal) intValues[encoderIndex] = maxVal;
}

// Initialize a single dial based on its configuration
void init_dial(uint8_t page, uint8_t dial_index, const encoder_dial_config_t* config) {
    uint8_t array_index = page * 8 + dial_index;
    
    switch (config->mode) {
        case MODE_FRAC_UNIPOLAR:
        case MODE_FRAC_BIPOLAR:
            dials[array_index].page = page;
            dials[array_index].param = config->param;
            dials[array_index].is_bipolar = (config->mode == MODE_FRAC_BIPOLAR);
            dials[array_index].x = COL_X[dial_index % 4];
            dials[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            dials[array_index].width = DIAL_WIDTH;
            dials[array_index].height = DIAL_HEIGHT;
            dials[array_index].label = config->label;
            dials[array_index].show_value = config->show_value;
            dials[array_index].default_value = config->default_value * (1 << 21);
            parent->instancesketchy__render_i.dial_init(&dials[array_index]);
            break;
            
        case MODE_INT:
            intdisplays[array_index].page = page;
            intdisplays[array_index].param = config->param;
            intdisplays[array_index].x = COL_X[dial_index % 4];
            intdisplays[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            intdisplays[array_index].width = DIAL_WIDTH;
            intdisplays[array_index].height = DIAL_HEIGHT;
            intdisplays[array_index].label = config->label;
            parent->instancesketchy__render_i.intdisplay_init(&intdisplays[array_index]);
            break;
            
        case MODE_LIST:
            selects[array_index].page = page;
            selects[array_index].param = config->param;
            selects[array_index].x = COL_X[dial_index % 4];
            selects[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            selects[array_index].width = DIAL_WIDTH;
            selects[array_index].height = DIAL_HEIGHT;
            selects[array_index].is_int = true;
            selects[array_index].label = config->options;
            parent->instancesketchy__render_i.select_init(&selects[array_index]);
            break;
    }
}

// Update a single dial based on its configuration
void update_dial(uint8_t page, uint8_t dial_index, const encoder_dial_config_t* config) {
    uint8_t array_index = page * 8 + dial_index;
    
    switch (config->mode) {
        case MODE_FRAC_UNIPOLAR:
        case MODE_FRAC_BIPOLAR:
            parent->instancesketchy__render_i.dial_update(&dials[array_index]);
            break;
            
        case MODE_INT:
            parent->instancesketchy__render_i.intdisplay_update(&intdisplays[array_index]);
            break;
            
        case MODE_LIST:
            parent->instancesketchy__render_i.select_update(&selects[array_index]);
            break;
    }
}]]></code.declaration>
      <code.init><![CDATA[// Initialize encoder values
for (int i = 0; i < 8; i++) {
    encoderPos[i] = 0.0f;  // Will be set to defaults below
    accel[i] = 1;
    lastTrigTime[i] = 0;
    lastTrigState[i] = 0;
    intValues[i] = 0;  // Will be set to defaults below
}
lastPage = -1;
timeCounter = 0;

// Initialize param table with default values
rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
int firstparam = attr_firstparam;

for (int page = 0; page < 8; page++) {
    for (int enc = 0; enc < 8; enc++) {
        const encoder_dial_config_t* config = &configs[page][enc];
        
        if (config->mode == MODE_INT || config->mode == MODE_LIST) {
            // Initialize integer/list modes to their default values (clamped to range)
            int default_int = (int)config->default_value;
            if (default_int < config->int_min) default_int = config->int_min;
            if (default_int > config->int_max) default_int = config->int_max;
            param_table->array[page][firstparam + enc] = default_int;
        } else {
            // Initialize fractional modes to default value
            param_table->array[page][firstparam + enc] = (int32_t)(config->default_value * (float)(1 << 27));
        }
    }
}

// Initialize local encoder arrays to match default values for page 0
for (int i = 0; i < 8; i++) {
    const encoder_dial_config_t* config = &configs[0][i];  // Use page 0 defaults
    
    if (config->mode == MODE_INT || config->mode == MODE_LIST) {
        int default_int = (int)config->default_value;
        if (default_int < config->int_min) default_int = config->int_min;
        if (default_int > config->int_max) default_int = config->int_max;
        intValues[i] = default_int;
    } else {
        float default_frac = config->default_value;
        default_frac = applyModeConstraints(default_frac, config->mode, i);
        encoderPos[i] = default_frac;
    }
}

// Initialize all dials for all pages
for (uint8_t page = 0; page < 8; page++) {
    for (uint8_t dial = 0; dial < 8; dial++) {
        init_dial(page, dial, &configs[page][dial]);
    }
}]]></code.init>
      <code.krate><![CDATA[timeCounter++;
int page = inlet_page;

// Handle page changes (including initial page 0)
if (inlet_page != lastPage && page >= 0 && page < 8) {
    // Save current values before switching (write to table)
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
    int firstparam = attr_firstparam;
    
    if (lastPage >= 0 && lastPage < 8) {
        for (int i = 0; i < 8; i++) {
            const encoder_dial_config_t* old_config = &configs[lastPage][i];
            int32_t value = 0;
            
            if (old_config->mode == MODE_INT || old_config->mode == MODE_LIST) {
                value = intValues[i];
            } else if (old_config->mode == MODE_FRAC_BIPOLAR) {
                // Convert bipolar (-1.0 to 1.0) to unipolar (0.0 to 1.0) for table storage
                float unipolar_value = (encoderPos[i] + 1.0f) * 0.5f;
                value = (int32_t)(unipolar_value * (float)(1 << 27));
            } else {
                // Unipolar mode - direct conversion
                value = (int32_t)(encoderPos[i] * (float)(1 << 27));
            }
            param_table->array[lastPage][firstparam + i] = value;
        }
    }
    
    // Load values for new page
    for (int i = 0; i < 8; i++) {
        const encoder_dial_config_t* config = &configs[page][i];
        
        if (config->mode == MODE_INT || config->mode == MODE_LIST) {
            loadIntValue(i, page);
        } else {
            // Load fractional value from table
            int32_t stored_value = param_table->array[page][firstparam + i];
            float table_value = (float)stored_value / (float)(1 << 27);
            
            if (config->mode == MODE_FRAC_BIPOLAR) {
                // Convert from unipolar table storage (0.0 to 1.0) back to bipolar (-1.0 to 1.0)
                encoderPos[i] = (table_value * 2.0f) - 1.0f;
            } else {
                // Unipolar mode - direct assignment
                encoderPos[i] = table_value;
            }
            encoderPos[i] = applyModeConstraints(encoderPos[i], config->mode, i);
        }
    }
    lastPage = inlet_page;
    
    // Debug: Force write current page defaults to verify they're loaded
    rootc::instancesketchy__params* debug_table = &parent->instancesketchy__params_i;
    for (int i = 0; i < 8; i++) {
        const encoder_dial_config_t* config = &configs[page][i];
        if (config->mode == MODE_INT || config->mode == MODE_LIST) {
            int default_int = (int)config->default_value;
            if (default_int < config->int_min) default_int = config->int_min;
            if (default_int > config->int_max) default_int = config->int_max;
            debug_table->array[page][attr_firstparam + i] = default_int;
        } else {
            debug_table->array[page][attr_firstparam + i] = (int32_t)(config->default_value * (float)(1 << 27));
        }
    }
}

// Process encoder inputs
bool trig[8] = {inlet_trig1, inlet_trig2, inlet_trig3, inlet_trig4, 
                inlet_trig5, inlet_trig6, inlet_trig7, inlet_trig8};
bool dir[8]  = {inlet_dir1,  inlet_dir2,  inlet_dir3,  inlet_dir4,  
                inlet_dir5,  inlet_dir6,  inlet_dir7,  inlet_dir8};

for (int i = 0; i < 8; i++) {
    bool edge = (trig[i] == 1) && (lastTrigState[i] == 0);
    lastTrigState[i] = trig[i];
    
    if (edge) {
        const encoder_dial_config_t* config = &configs[page][i];
        
        if (config->mode == MODE_INT || config->mode == MODE_LIST) {
            updateIntValue(i, dir[i], page);
            // Write INT/LIST value to param table immediately
            rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
            param_table->array[page][attr_firstparam + i] = intValues[i];
        } else {
            uint32_t diff = timeCounter - lastTrigTime[i];
            if (diff < attr_acceltime) {
                accel[i]++;
                if (accel[i] > attr_accelmultiplier) accel[i] = attr_accelmultiplier;
            } else {
                accel[i] = 1;
            }
            float inc = 0.0078125f * accel[i];
            if (dir[i] == 0) {
                encoderPos[i] -= inc;
            } else {
                encoderPos[i] += inc;
            }
            encoderPos[i] = applyModeConstraints(encoderPos[i], config->mode, i);
            
            // Write FRAC value to param table immediately
            rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
            int32_t value;
            if (config->mode == MODE_FRAC_BIPOLAR) {
                // Convert bipolar (-1.0 to 1.0) to unipolar (0.0 to 1.0) for table storage
                float unipolar_value = (encoderPos[i] + 1.0f) * 0.5f;
                value = (int32_t)(unipolar_value * (float)(1 << 27));
            } else {
                // Unipolar mode - direct conversion
                value = (int32_t)(encoderPos[i] * (float)(1 << 27));
            }
            param_table->array[page][attr_firstparam + i] = value;
        }
        lastTrigTime[i] = timeCounter;
    }
}

// Update displays for current page only
for (uint8_t dial = 0; dial < 8; dial++) {
    update_dial(page, dial, &configs[page][dial]);
}

// Output values for patch compatibility
outlet_o1 = (configs[page][0].mode == MODE_INT || configs[page][0].mode == MODE_LIST) ? 0 : (int)(encoderPos[0] * (float)(1 << 27));
outlet_o2 = (configs[page][1].mode == MODE_INT || configs[page][1].mode == MODE_LIST) ? 0 : (int)(encoderPos[1] * (float)(1 << 27));
outlet_o3 = (configs[page][2].mode == MODE_INT || configs[page][2].mode == MODE_LIST) ? 0 : (int)(encoderPos[2] * (float)(1 << 27));
outlet_o4 = (configs[page][3].mode == MODE_INT || configs[page][3].mode == MODE_LIST) ? 0 : (int)(encoderPos[3] * (float)(1 << 27));
outlet_o5 = (configs[page][4].mode == MODE_INT || configs[page][4].mode == MODE_LIST) ? 0 : (int)(encoderPos[4] * (float)(1 << 27));
outlet_o6 = (configs[page][5].mode == MODE_INT || configs[page][5].mode == MODE_LIST) ? 0 : (int)(encoderPos[5] * (float)(1 << 27));
outlet_o7 = (configs[page][6].mode == MODE_INT || configs[page][6].mode == MODE_LIST) ? 0 : (int)(encoderPos[6] * (float)(1 << 27));
outlet_o8 = (configs[page][7].mode == MODE_INT || configs[page][7].mode == MODE_LIST) ? 0 : (int)(encoderPos[7] * (float)(1 << 27));

// Debug outputs
rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
int firstparam = attr_firstparam;
outlet_debugintval = (page >= 0 && page < 8) ? intValues[0] : -1;
outlet_debugtableval = (page >= 0 && page < 8) ? param_table->array[page][firstparam] : -1;]]></code.krate>
   </obj.normal>
</objdefs> 