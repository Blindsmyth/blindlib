<objdefs appVersion="1.0.12">
   <obj.normal id="8encoder_input" uuid="7d3e8f1a-2b9c-4d5e-8f6a-1c2d3e4f5a6b">
      <sDescription>8 rotary encoders with acceleration. Reads configuration from sketchy_dials and writes directly to param table.</sDescription>
      <author>AI Assistant</author>
      <license>BSD</license>
      <helpPatch>logic.axh</helpPatch>
      <inlets>
         <bool32.rising name="trig1"/>
         <bool32.rising name="dir1"/>
         <bool32.rising name="trig2"/>
         <bool32.rising name="dir2"/>
         <bool32.rising name="trig3"/>
         <bool32.rising name="dir3"/>
         <bool32.rising name="trig4"/>
         <bool32.rising name="dir4"/>
         <bool32.rising name="trig5"/>
         <bool32.rising name="dir5"/>
         <bool32.rising name="trig6"/>
         <bool32.rising name="dir6"/>
         <bool32.rising name="trig7"/>
         <bool32.rising name="dir7"/>
         <bool32.rising name="trig8"/>
         <bool32.rising name="dir8"/>
         <int32 name="page"/>
      </inlets>
      <outlets>
         <int32 name="debugintval"/>
         <int32 name="debugtableval"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <spinner name="acceltime" MinValue="1" MaxValue="1000" DefaultValue="100"/>
         <spinner name="accelmultiplier" MinValue="1" MaxValue="10" DefaultValue="6"/>
      </attribs>
      <code.declaration><![CDATA[// Encoder data and page management
float encoderPos[8];
int accel[8];
uint32_t lastTrigTime[8];
int lastTrigState[8];
uint32_t timeCounter = 0;
int lastPage = -1;

// Mode constants - must match sketchy_dials
#define MODE_FRAC_UNIPOLAR 0
#define MODE_FRAC_BIPOLAR  1
#define MODE_INT           2
#define MODE_LIST          3
#define MODE_BAR_UNIPOLAR  4
#define MODE_BAR_BIPOLAR   5

// Helper function for basic constraints
float applyConstraints(float value) {
    if(value < 0.0f) return 0.0f;
    if(value > 1.0f) return 1.0f;
    return value;
}

// Convert from display value to encoder position (0-1)
float displayToEncoderValue(float displayValue, int mode) {
    switch(mode) {
        case MODE_FRAC_UNIPOLAR:
        case MODE_BAR_UNIPOLAR:
            return displayValue / 64.0f;
        case MODE_FRAC_BIPOLAR:
        case MODE_BAR_BIPOLAR:
            return (displayValue + 64.0f) / 128.0f;
        case MODE_INT:
        case MODE_LIST:
            return 0.0f;  // Not used for these modes
        default:
            return displayValue;
    }
}

// Load values from param table for page change
void loadPageValues(int page) {
    if (page < 0 || page >= 8) return;
    
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
    
    for (int i = 0; i < 8; i++) {
        // Access configuration via parent shared table
        auto& config = parent->instancesketchy__dials_i.configs[page][i];
        
        if (config.mode == MODE_INT || config.mode == MODE_LIST) {
            // For INT/LIST modes, param table stores actual integer values
            // No need to load into encoderPos - values stay in param table
        } else {
            // For fractional modes, load encoder position from param table
            int32_t stored_value = param_table->array[page][i];
            encoderPos[i] = (float)stored_value / (float)(1 << 27);
            encoderPos[i] = applyConstraints(encoderPos[i]);
        }
    }
}

// Save values to param table for page change
void savePageValues(int page) {
    if (page < 0 || page >= 8) return;
    
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
    
    for (int i = 0; i < 8; i++) {
        // Access configuration via parent shared table
        auto& config = parent->instancesketchy__dials_i.configs[page][i];
        
        if (config.mode == MODE_INT || config.mode == MODE_LIST) {
            // INT/LIST modes: values already stored directly in param table
            // Nothing to do here
        } else {
            // Fractional modes: store encoder positions
            int32_t value = (int32_t)(encoderPos[i] * (float)(1 << 27));
            param_table->array[page][i] = value;
        }
    }
}]]></code.declaration>
      <code.init><![CDATA[// Initialize encoder values
for (int i = 0; i < 8; i++) {
    encoderPos[i] = 0.0f;
    accel[i] = 1;
    lastTrigTime[i] = 0;
    lastTrigState[i] = 0;
}
timeCounter = 0;
lastPage = -1;]]></code.init>
      <code.krate><![CDATA[timeCounter++;
int page = inlet_page;

// Handle page changes
if (page != lastPage && page >= 0 && page < 8) {
    // Save current page values before switching
    if (lastPage >= 0 && lastPage < 8) {
        savePageValues(lastPage);
    }
    
    // Load new page values
    loadPageValues(page);
    lastPage = page;
}

// Process encoder inputs with mode-specific logic
if (page >= 0 && page < 8) {
    bool trig[8] = {inlet_trig1, inlet_trig2, inlet_trig3, inlet_trig4, 
                    inlet_trig5, inlet_trig6, inlet_trig7, inlet_trig8};
    bool dir[8]  = {inlet_dir1,  inlet_dir2,  inlet_dir3,  inlet_dir4,  
                    inlet_dir5,  inlet_dir6,  inlet_dir7,  inlet_dir8};

    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;

    for (int i = 0; i < 8; i++) {
        bool edge = (trig[i] == 1) && (lastTrigState[i] == 0);
        lastTrigState[i] = trig[i];

        if (edge) {
            // Access configuration via parent shared table
            auto& config = parent->instancesketchy__dials_i.configs[page][i];

            // Acceleration logic
            uint32_t diff = timeCounter - lastTrigTime[i];
            if (diff < attr_acceltime) {
                accel[i]++;
                if (accel[i] > attr_accelmultiplier) accel[i] = attr_accelmultiplier;
            } else {
                accel[i] = 1;
            }
            
            if (config.mode == MODE_INT || config.mode == MODE_LIST) {
                // Integer/List mode: increment/decrement actual integer values
                int current_value = param_table->array[page][i];
                
                if (dir[i] == 0) {
                    current_value -= accel[i];
                } else {
                    current_value += accel[i];
                }
                
                // Clamp to range
                if (current_value < config.int_min) current_value = config.int_min;
                if (current_value > config.int_max) current_value = config.int_max;
                
                // Store directly in param table
                param_table->array[page][i] = current_value;
                
            } else {
                // Fractional mode: use encoder positions
                float inc = 0.0078125f * accel[i]; // 1/128 * acceleration
                if (dir[i] == 0) {
                    encoderPos[i] -= inc;
                } else {
                    encoderPos[i] += inc;
                }
                
                encoderPos[i] = applyConstraints(encoderPos[i]);
                
                // Store encoder position in param table
                int32_t value = (int32_t)(encoderPos[i] * (float)(1 << 27));
                param_table->array[page][i] = value;
            }
            
            lastTrigTime[i] = timeCounter;
        }
    }
}

// Debug outputs
rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
outlet_debugintval = (page >= 0 && page < 8) ? param_table->array[page][0] : 0;
outlet_debugtableval = (page >= 0 && page < 8) ? param_table->array[page][0] : 0;]]></code.krate>
   </obj.normal>
</objdefs>