<objdefs appVersion="1.0.12">
   <obj.normal id="sketchy_render" uuid="5224773f-18de-4231-8f92-b1f22bb95372">
      <sDescription>The renderer object continuously renders visual objects to a connected SSD1306/1106 OLED display. Objects and texts must be defined and configured in the respective tables. Use a sketchy/object/table and sketchy/object/update to initialize and configure all visual elements. For rendering text you will also need a sketchy/text/table and sketchy/text/update. If you do not want to render text, just initialize an empty sketchy/text/table and set entries to 0.</sDescription>
      <author>Karlo Sono</author>
      <license>MIT</license>
      <inlets>
         <int32.positive name="page" description="set current page"/>
         <int32.positive name="layout" description="set layout page (always visible)"/>
         <bool32.rising name="print" description="Will log the state of the object table to axoloti window"/>
      </inlets>
      <outlets>
         <int32.positive name="sw" description="screen width"/>
         <int32.positive name="sh" description="screen height"/>
      </outlets>
      <displays/>
      <params/>
      <attribs>
         <combo name="type">
            <MenuEntries>
               <string>SSD1306</string>
               <string>SH1106</string>
            </MenuEntries>
            <CEntries>
               <string>1306</string>
               <string>1106</string>
            </CEntries>
         </combo>
         <combo name="I2CADDR">
            <MenuEntries>
               <string>0x3C</string>
               <string>0x3D</string>
            </MenuEntries>
            <CEntries>
               <string>0x3C</string>
               <string>0x3D</string>
            </CEntries>
         </combo>
      </attribs>
      <includes/>
      <depends>
         <depend>SD1</depend>
         <depend>I2CD1</depend>
         <depend>SPID1</depend>
      </depends>
      <code.declaration><![CDATA[rootc::instancesketchy__objects* object_table;
rootc::instancesketchy__texts* text_table;
rootc::instancesketchy__params* param_table;
rootc::instancesketchy__font* font;

uint16_t page;
uint16_t layout;

// ================ VIRTUAL KNOB CONSTANTS ================
#define CIRCLE_POINTS 44
#define INDICATOR_POSITIONS 31

enum SSD1306 {
	LCDWIDTH            = 128,
	LCDHEIGHT           = 64,
	SETCONTRAST         = 0x81,
	DISPLAYON           = 0xAF,
	DISPLAYOFF          = 0xAE,
	DISPLAYALLON_RESUME = 0xA4,
	NORMALDISPLAY       = 0xA6,
	DEACTIVATE_SCROLL   = 0x2E,
	MEMORYMODE          = 0x20,
	COLUMNADDR          = 0x21,
	PAGEADDR            = 0x22,
	SETSTARTLINE_0      = 0x40,
	SEGREMAP            = 0xA0,
	SETMULTIPLEX        = 0xA8,
	COMSCANDEC          = 0xC8,
	SETDISPLAYOFFSET    = 0xD3,
	SETCOMPINS          = 0xDA,
	SETDISPLAYCLOCKDIV  = 0xD5,
	SETPRECHARGE        = 0xD9,
	SETVCOMDETECT       = 0xDB,
	CHARGEPUMP          = 0x8D,
	EXTERNALVCC         = 0x1,
	SWITCHCAPVCC        = 0x2,
};

uint8_t pixels[8][LCDWIDTH];
uint8_t cpt = 0;
uint8_t *txbuf;
uint8_t *rxbuf;

void cmd(uint8_t c) {
	txbuf[0] = 0;
	txbuf[1] = c;
	i2cMasterTransmitTimeout(&I2CD1, attr_I2CADDR, txbuf, 2, rxbuf, 0, 30);
}

int wrap_index(int i, int i_max) {
	return ((i % i_max) + i_max) % i_max;
}

void clear() {
	for (int page = 0; page < 8; page++) {
		for (int i = 0; i < LCDWIDTH; i++) {
			pixels[page][i] = 0;
		}
	}
}

void sendPage(int page) {
	cmd(COLUMNADDR); cmd(0); cmd(127);
	cmd(PAGEADDR); cmd(page); cmd(page);

	if (attr_type == 1106) {
		cmd(0xB0 + page);
		cmd(2 & 0xf);
		cmd(0x10 | (2 >> 4));
	}

	txbuf[0] = 0x40;
	memcpy(txbuf + 1, pixels[page], LCDWIDTH);
	i2cMasterTransmitTimeout(&I2CD1, attr_I2CADDR, txbuf, 129, rxbuf, 0, 30);
}

void init() {
	cmd(DISPLAYOFF);
	cmd(SETDISPLAYCLOCKDIV); cmd(0x80);
	cmd(SETMULTIPLEX); cmd(LCDHEIGHT - 1);
	cmd(SETDISPLAYOFFSET); cmd(attr_type == 1306 ? 0x00 : 0x01);
	cmd(SETSTARTLINE_0);
	cmd(CHARGEPUMP); cmd(0x14);
	cmd(MEMORYMODE); cmd(0x00);
	cmd(SEGREMAP | 0x1);
	cmd(COMSCANDEC);
	cmd(SETCOMPINS); cmd(0x12);
	cmd(SETCONTRAST); cmd(0xCF);
	cmd(SETPRECHARGE); cmd(0xF1);
	cmd(SETVCOMDETECT); cmd(0x40);
	cmd(DISPLAYALLON_RESUME);
	cmd(NORMALDISPLAY);
	cmd(DEACTIVATE_SCROLL);
	cmd(DISPLAYON);
}

void setup() {
	static uint8_t _txbuf[129] __attribute__ ((section (".sram2")));
	static uint8_t _rxbuf[8] __attribute__ ((section (".sram2")));
	txbuf = _txbuf;
	rxbuf = _rxbuf;
	init();
}

msg_t ThreadX2() {
	setup();
	while (!chThdShouldTerminate()) {
		clear();
		render();
		uint8_t i; 
		for (i = 0; i < 8; i++) {
			sendPage(i);
		}
		chThdSleepMilliseconds(32);
	}
	chThdExit((msg_t)0);
}

static msg_t ThreadX(void *arg) {
	((attr_parent *)arg)->ThreadX2();
}

WORKING_AREA(waThreadX, 2048);
Thread *Thd;

uint16_t fps_limit_counter;
bool pprint;
bool prender;

void draw_pixel(int16_t x, int16_t y, uint8_t color) __attribute__ ((noinline)) {
	uint8_t page, bit;
	if (x < 0 || y < 0 || x >= LCDWIDTH || y >= LCDHEIGHT - 1) {
		return;
	}
	page = y / 8;
	bit = 0x01;
	bit <<= (y % 8);
	if (color == 0) { 
		pixels[page][x] |= bit;
	} else if (color == 1) { 
		pixels[page][x] &= ~bit;
	} else if (color == 2) { 
		pixels[page][x] ^= bit;
	}
}

void draw_scaled_pixel(int16_t x, int16_t y, uint8_t color, uint8_t scale = 1) __attribute__ ((noinline)) {
	if (scale == 0) {
		scale = 1;
	}
	for (int i = 0; i < scale; i++) {
		for (int j = 0; j < scale; j++) {
			int16_t scaled_x = x * scale + i;
			int16_t scaled_y = y * scale + j;
			draw_pixel(scaled_x, scaled_y, color);
		}
	}
}

#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

void draw_line(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint8_t color, uint8_t scale = 1) __attribute__ ((noinline)) {
	int16_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {    
		_swap_int16_t(x0, y0);
		_swap_int16_t(x1, y1);
	}
	if (x0 > x1) {
		_swap_int16_t(x0, x1);
		_swap_int16_t(y0, y1);
	}
	int16_t dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);
	int16_t err = dx / 2;
	int16_t ystep;
	if (y0 < y1) {
		ystep = 1;
	} else {
		ystep = -1;
	}
	for (; x0 <= x1; x0++) {
		if (steep) {
			draw_scaled_pixel(y0, x0, color, scale);
		} else {
			draw_scaled_pixel(x0, y0, color, scale);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
			err += dx;
		}
	}
}

void draw_string_from_index(int text_id, int16_t x, int16_t y, int16_t w, int16_t h, uint8_t color, bool center, bool center_v = false, uint8_t scale = 1) __attribute__ ((noinline)) {
    const char* str = parent->instancesketchy__texts_i.array[text_id];
    int16_t char_width = 5;
    int16_t char_spacing = 1;
    int16_t total_char_width = char_width + char_spacing;
    int16_t char_height = font->height;
    size_t max_length = parent->instancesketchy__texts_i.STRING_LENGTH;

    int total_lines = 0;
    if (center_v) {
        size_t i = 0;
        while (i < max_length && str[i] != '\0') {
            int line_width = 0;
            size_t last_space = (size_t)-1;
            while (i < max_length && str[i] != '\0' && str[i] != '\n') {
                if (str[i] == ' ') {
                    last_space = i;
                }
                if (line_width + total_char_width > w) {
                    if (last_space != (size_t)-1) {
                        i = last_space + 1;
                        break;
                    }
                }
                line_width += total_char_width;
                i++;
            }
            total_lines++;
            if (i < max_length && str[i] == '\n') i++;
        }
    }

    int16_t total_height = total_lines * char_height;
    int16_t start_y;
    if (center_v) {
        start_y = y + (h - total_height) / 2;
        start_y = (start_y < y) ? y : start_y;
    } else {
        start_y = y;
    }

    size_t i = 0;
    int16_t current_y = start_y;

    while (i < max_length && str[i] != '\0' && current_y + char_height <= y + h) {
        size_t line_start = i;
        int16_t line_width = 0;
        size_t last_space = (size_t)-1;
        
        while (i < max_length && str[i] != '\0' && str[i] != '\n') {
            if (str[i] == ' ') {
                last_space = i;
            }
            if (line_width + total_char_width > w) {
                if (last_space != (size_t)-1) {
                    i = last_space;
                    line_width = (int16_t)(i - line_start) * total_char_width;
                }
                break;
            }
            line_width += total_char_width;
            i++;
        }
        
        while (i > line_start && str[i - 1] == ' ') {
            i--;
            line_width -= total_char_width;
        }

        int16_t x_offset = center ? (w - (line_width - char_spacing)) / 2 : 0;
        
        for (size_t j = line_start; j < i && j < max_length; j++) {
            int16_t current_x = x + x_offset + (int16_t)(j - line_start) * total_char_width;
            
            if (current_x + char_width <= x + w && current_y + char_height <= y + h) {
                draw_char_clipped(str[j], current_x, current_y, 0, 0, char_width, char_height, color, scale);
            }
        }

        current_y += char_height;
        if (i < max_length && (str[i] == '\n' || str[i] == ' ')) i++;
    }
}

void draw_char_clipped(char c, int16_t x, int16_t y, int16_t clip_x, int16_t clip_y, int16_t clip_w, int16_t clip_h, uint8_t color, uint8_t scale = 1) __attribute__ ((noinline)) {
	if (c < 32 || c > 127) {
		return;
	}
	int index = (c - 32) * 5;
	for (int col = clip_x; col < clip_x + clip_w && col < 5; col++) {
		uint8_t column_data = font->data[index + col];
		for (int row = clip_y; row < clip_y + clip_h && row < 8; row++) {
			if (column_data & (1 << row)) {
				draw_scaled_pixel(x + col - clip_x, y + row - clip_y, color, scale);
			}
		}
	}
}

void draw_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint8_t color, uint8_t scale = 1) __attribute__ ((noinline)) {
	if (w == 0 || h == 0) return;
	int16_t x_end = x + w - (w > 0 ? 1 : -1);
	int16_t y_end = y + h - (h > 0 ? 1 : -1);
	draw_line(x, y, x_end, y, color, scale);
	if (h != 1 && h != -1) {
		draw_line(x, y_end, x_end, y_end, color, scale);
	}
	if (w != 1 && w != -1) {
		draw_line(x, y, x, y_end, color, scale);
		draw_line(x_end, y, x_end, y_end, color, scale);
	}
}

void draw_filled_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint8_t color, uint8_t scale = 1) __attribute__ ((noinline)) {
	if (w == 0 || h == 0) return;
	int16_t x_start = (w > 0) ? x : x + w + 1;
	int16_t x_end = (w > 0) ? x + w : x + 1;
	int16_t y_start = (h > 0) ? y : y + h + 1;
	int16_t y_end = (h > 0) ? y + h : y + 1;
	for (int16_t i = x_start; i != x_end; i += (w > 0 ? 1 : -1)) {
		draw_line(i, y_start, i, y_end - 1, color, scale);
	}
}

void draw_rounded_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint8_t color, uint8_t scale = 1) __attribute__ ((noinline)) {
	if (abs(w) < 5 || abs(h) < 5) {
		draw_rect(x, y, w, h, color, scale);
		return;
	}
	int16_t x_end = x + w - (w > 0 ? 1 : -1);
	int16_t y_end = y + h - (h > 0 ? 1 : -1);
	draw_line(x + 2, y, x_end - 2, y, color, scale);
	draw_line(x + 2, y_end, x_end - 2, y_end, color, scale);
	draw_line(x, y + 2, x, y_end - 2, color, scale);
	draw_line(x_end, y + 2, x_end, y_end - 2, color, scale);
	draw_scaled_pixel(x + 1, y + 1, color, scale);
	draw_scaled_pixel(x_end - 1, y + 1, color, scale);
	draw_scaled_pixel(x + 1, y_end - 1, color, scale);
	draw_scaled_pixel(x_end - 1, y_end - 1, color, scale);
}

void draw_filled_rounded_rect(int16_t x, int16_t y, int16_t w, int16_t h, uint8_t color, uint8_t scale = 1) __attribute__ ((noinline)) {
	if (abs(w) < 5 || abs(h) < 5) {
		draw_filled_rect(x, y, w, h, color, scale);
		return;
	}
	int16_t x_start = (w > 0) ? x : x + w + 1;
	int16_t x_end = (w > 0) ? x + w : x + 1;
	int16_t y_start = (h > 0) ? y : y + h + 1;
	int16_t y_end = (h > 0) ? y + h : y + 1;
	for (int16_t i = x_start; i != x_end; i += (w > 0 ? 1 : -1)) {
		int16_t start_y = y_start;
		int16_t end_y = y_end - 1;
		if (i == x_start || i == x_end - (w > 0 ? 1 : -1)) {
			start_y += 2;
			end_y -= 2;
		} else if (i == x_start + (w > 0 ? 1 : -1) || i == x_end - (w > 0 ? 2 : -2)) {
			start_y += 1;
			end_y -= 1;
		}
		draw_line(i, start_y, i, end_y, color, scale);
	}
}

void render() __attribute__ ((noinline)) {
	for (uint8_t i = 0; i < parent->instancesketchy__objects_i.LENGTH; i++) {
		if (parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TYPE] == parent->instancesketchy__objects_i.TYPE_INVISIBLE) {
			continue;
		}
		uint16_t current_object_page = parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_PAGE];
		if (current_object_page != page && current_object_page != layout) {
			continue;
		}
		
		int16_t x = parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_X];
		int16_t y = parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_Y];
		int16_t w = parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_W];
		int16_t h = parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_H];
		uint8_t color = parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_COLOR];
		uint8_t scale = parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_SCALE];

		switch (parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TYPE]) {
			case parent->instancesketchy__objects_i.TYPE_RECT:
				draw_rect(x, y, w, h, color, scale);
				break;
			case parent->instancesketchy__objects_i.TYPE_FILLED_RECT:
				draw_filled_rect(x, y, w, h, color, scale);
				break;
			case parent->instancesketchy__objects_i.TYPE_ROUNDED_RECT:
				draw_rounded_rect(x, y, w, h, color, scale);
				break;
			case parent->instancesketchy__objects_i.TYPE_FILLED_ROUNDED_RECT:
				draw_filled_rounded_rect(x, y, w, h, color, scale);
				break;
			case parent->instancesketchy__objects_i.TYPE_LINE:
				if (i > 0 && parent->instancesketchy__objects_i.array[i - 1][parent->instancesketchy__objects_i.FIELD_TYPE] == parent->instancesketchy__objects_i.TYPE_LINE) {
					int16_t prev_x = parent->instancesketchy__objects_i.array[i - 1][parent->instancesketchy__objects_i.FIELD_X];
					int16_t prev_y = parent->instancesketchy__objects_i.array[i - 1][parent->instancesketchy__objects_i.FIELD_Y];
					draw_line(prev_x, prev_y, x, y, color, scale);
				}
				break;
			case parent->instancesketchy__objects_i.TYPE_TEXT:
				draw_string_from_index(parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TEXT_ID], x, y, w, h, color, false, false, scale);
				break;
			case parent->instancesketchy__objects_i.TYPE_TEXT_CENTER_X:
				draw_string_from_index(parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TEXT_ID], x, y, w, h, color, true, false, scale);
				break;
			case parent->instancesketchy__objects_i.TYPE_TEXT_CENTER_Y:
				draw_string_from_index(parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TEXT_ID], x, y, w, h, color, false, true, scale);
				break;
			case parent->instancesketchy__objects_i.TYPE_TEXT_CENTER_BOTH:
				draw_string_from_index(parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TEXT_ID], x, y, w, h, color, true, true, scale);
				break;
				
			case 99: // VIRTUAL KNOB TYPE (unipolar)
				{
					// x, y = center coordinates
					// w = indicator_index 
					// h = dial width (for bounds checking)
					
					int cx = x;
					int cy = y;
					int indicator_index = w;
					
					// Draw circle using our lookup table (gap already built in at bottom)
					for (int ci = 0; ci < CIRCLE_POINTS; ci++) {
						int circle_x = cx + circle_coords[ci][0];
						int circle_y = cy + circle_coords[ci][1];
						draw_pixel(circle_x, circle_y, color);
					}
					
					// Draw indicator line from center to exact position using lookup table
					draw_indicator_line(cx, cy, indicator_index);
				}
				break;
				
			case 100: // BIPOLAR VIRTUAL KNOB TYPE
				{
					// x, y = center coordinates
					// w = indicator_index 
					// h = dial width (for bounds checking)
					
					int cx = x;
					int cy = y;
					int indicator_index = w;
					
					// Draw circle using our lookup table (gap already built in at bottom)
					for (int ci = 0; ci < CIRCLE_POINTS; ci++) {
						int circle_x = cx + circle_coords[ci][0];
						int circle_y = cy + circle_coords[ci][1];
						draw_pixel(circle_x, circle_y, color);
					}
					
					// Draw bipolar indicators (- and + at edges)
					draw_bipolar_indicators(cx, cy);
					
					// Draw indicator line from center to exact position using lookup table
					draw_indicator_line(cx, cy, indicator_index);
				}
				break;
		}
	}
	parent->instancesketchy__objects_i.dirty = false;
}

uint16_t getCurrentPage() __attribute__ ((noinline)) {
	return page;
}

char* tokenize(char* str, const char* delim, char** saveptr) __attribute__ ((noinline)) {
    char* current = str ? str : *saveptr;
    if (current == NULL) {
        return NULL;
    }
    while (*current && strchr(delim, *current)) {
        current++;
    }
    if (*current == '\0') {
        *saveptr = NULL;
        return NULL;
    }
    char* start = current;
    while (*current && !strchr(delim, *current)) {
        current++;
    }
    if (*current) {
        *current = '\0';
        *saveptr = current + 1;
    } else {
        *saveptr = NULL;
    }
    return start;
}

char* get_token_at_index(const char* str, int desired_index) __attribute__ ((noinline)) {
    char buffer[256];
    char* saveptr = NULL;
    strncpy(buffer, str, sizeof(buffer)-1);
    buffer[sizeof(buffer)-1] = '\0';
    char* token = tokenize(buffer, ",", &saveptr);
    for (int i = 0; i < desired_index && token != NULL; i++) {
        token = tokenize(NULL, ",", &saveptr);
    }
    return token;
}

int count_tokens(const char* str) __attribute__ ((noinline)) {
    if (!str || *str == '\0') return 0;
    int count = 1;
    for (const char* p = str; *p != '\0'; p++) {
        if (*p == ',' && *(p+1) != ',' && *(p+1) != '\0') {
            count++;
        }
    }
    return count;
}

// RENAMED: dial -> bar (vertical bar display)
typedef struct {
    uint16_t box_object_id;
    uint16_t label_object_id;
    uint16_t label_text_id;
    int32_t last_value;
    int32_t page;
    int32_t param;
    bool is_bipolar;
    int32_t x;
    int32_t y;
    int32_t width;
    int32_t height;
    const char* label;
    bool show_value;
    int32_t default_value;
} bar_t;

void bar_init(bar_t* bar) __attribute__ ((noinline)) { 
   rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
   rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
   rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;

   bar->box_object_id = object_table->registerEntry();
   bar->label_object_id = object_table->registerEntry();
   bar->label_text_id = text_table->registerEntry();

   object_table->array[bar->box_object_id][object_table->FIELD_TYPE] = 2;
   object_table->array[bar->box_object_id][object_table->FIELD_X] = bar->x;
   object_table->array[bar->box_object_id][object_table->FIELD_Y] = bar->y;
   object_table->array[bar->box_object_id][object_table->FIELD_W] = bar->width;
   object_table->array[bar->box_object_id][object_table->FIELD_H] = 0;
   object_table->array[bar->box_object_id][object_table->FIELD_COLOR] = 0;
   object_table->array[bar->box_object_id][object_table->FIELD_SCALE] = 1;
   object_table->array[bar->box_object_id][object_table->FIELD_TEXT_ID] = 0;
   object_table->array[bar->box_object_id][object_table->FIELD_PAGE] = bar->page;

   object_table->array[bar->label_object_id][object_table->FIELD_TYPE] = 9;
   object_table->array[bar->label_object_id][object_table->FIELD_X] = bar->x;
   object_table->array[bar->label_object_id][object_table->FIELD_Y] = bar->y;
   object_table->array[bar->label_object_id][object_table->FIELD_W] = bar->width;
   object_table->array[bar->label_object_id][object_table->FIELD_H] = bar->height;
   object_table->array[bar->label_object_id][object_table->FIELD_COLOR] = 2;
   object_table->array[bar->label_object_id][object_table->FIELD_SCALE] = 1;
   object_table->array[bar->label_object_id][object_table->FIELD_TEXT_ID] = bar->label_text_id;
   object_table->array[bar->label_object_id][object_table->FIELD_PAGE] = bar->page;

   strcpy(text_table->array[bar->label_text_id], bar->label);
   param_table->array[bar->page][bar->param] = bar->default_value;
}

void bar_update(bar_t* bar) __attribute__ ((noinline)) {
   rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
   rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
   rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
	
   int32_t value = param_table->array[bar->page][bar->param];

   if (value == bar->last_value) {
       return;
   }
   bar->last_value = value;

   if (bar->is_bipolar) {
       value = (value-(1<<26))<<1;
   }

   float frac_value = ((float)value / 0x00200000);
   float norm_value = frac_value / 64.0f;

   if (bar->is_bipolar) {
       int8_t h = (bar->height/2.0f) * norm_value + 0.5f;
       object_table->array[bar->box_object_id][object_table->FIELD_H] = h;
       object_table->array[bar->box_object_id][object_table->FIELD_Y] = bar->y+(bar->height-h) - bar->height/2;
   } else {
       uint8_t h = bar->height * norm_value + 0.5f;
       object_table->array[bar->box_object_id][object_table->FIELD_H] = h;
       object_table->array[bar->box_object_id][object_table->FIELD_Y] = bar->y+(bar->height-h);
   }

   if (bar->show_value) {
       int rounded = (frac_value >= 0) ? (int)(frac_value + 0.5) : (int)(frac_value - 0.5);
       char value_str[8] = "";
       text_table->itoa(value_str, rounded);
       strcpy(text_table->array[bar->label_text_id], bar->label);
       strcat(text_table->array[bar->label_text_id], " ");
       strcat(text_table->array[bar->label_text_id], value_str);
   }
}

typedef struct {
    uint16_t box_object_id;
    uint16_t label_object_id;
    uint16_t label_text_id;
    int32_t last_value;
    int32_t page;
    int32_t param;
    int32_t x;
    int32_t y;
    int32_t width;
    int32_t height;
    const char* label;
    uint8_t num_options;
    bool is_int;
} select_t;

void select_init(select_t* select) __attribute__ ((noinline)) { 
   rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
   rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
   rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;

   // Calculate vertical offset for alignment: positions 0-3 up 2px, positions 4-7 up 1px
   bool is_second_row = (select->y >= 32);
   int y_offset = is_second_row ? -1 : -2;  // Move up 1px for second row, 2px for first row

   select->box_object_id = object_table->registerEntry();
   select->label_object_id = object_table->registerEntry();
   select->label_text_id = text_table->registerEntry();

   object_table->array[select->box_object_id][object_table->FIELD_TYPE] = 1;
   object_table->array[select->box_object_id][object_table->FIELD_X] = select->x;
   object_table->array[select->box_object_id][object_table->FIELD_Y] = select->y + y_offset;
   object_table->array[select->box_object_id][object_table->FIELD_W] = select->width;
   object_table->array[select->box_object_id][object_table->FIELD_H] = select->height;
   object_table->array[select->box_object_id][object_table->FIELD_COLOR] = 0;
   object_table->array[select->box_object_id][object_table->FIELD_SCALE] = 1;
   object_table->array[select->box_object_id][object_table->FIELD_TEXT_ID] = 0;
   object_table->array[select->box_object_id][object_table->FIELD_PAGE] = select->page;

   object_table->array[select->label_object_id][object_table->FIELD_TYPE] = 9;
   object_table->array[select->label_object_id][object_table->FIELD_X] = select->x;
   object_table->array[select->label_object_id][object_table->FIELD_Y] = select->y + y_offset;
   object_table->array[select->label_object_id][object_table->FIELD_W] = select->width;
   object_table->array[select->label_object_id][object_table->FIELD_H] = select->height;
   object_table->array[select->label_object_id][object_table->FIELD_COLOR] = 2;
   object_table->array[select->label_object_id][object_table->FIELD_SCALE] = 1;
   object_table->array[select->label_object_id][object_table->FIELD_TEXT_ID] = select->label_text_id;
   object_table->array[select->label_object_id][object_table->FIELD_PAGE] = select->page;

   select->num_options = count_tokens(select->label);
   strcpy(text_table->array[select->label_text_id], select->label);
   select->last_value = 0xFFFFFFFF;
}

void select_update(select_t* select) __attribute__ ((noinline)) {
   rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
   rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
   rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;
	
   int32_t value = param_table->array[select->page][select->param];
   int option_index = 0;

   if (value == select->last_value) {
       return;
   }
   select->last_value = value;

   if (select->is_int) {
      option_index = value;
   } else {
      float frac_value = ((float)value / 0x00200000);
      float option_range = 64.0f / select->num_options;
      option_index = (int)(frac_value / option_range);
   }
	
   option_index = (option_index >= select->num_options) ? select->num_options-1 : option_index;
   char* token = get_token_at_index(select->label, option_index);
   strcpy(text_table->array[select->label_text_id], token);
}

typedef struct {
    uint16_t box_object_id;
    uint16_t value_object_id;  // Text object for the numeric value inside box
    uint16_t label_object_id;
    uint16_t value_text_id;    // Text content for numeric value
    uint16_t label_text_id;
    int32_t last_value;
    int32_t page;
    int32_t param;
    int32_t x;
    int32_t y;
    int32_t width;
    int32_t height;
    const char* label;
} intdisplay_t;

void intdisplay_init(intdisplay_t* disp) __attribute__ ((noinline)) {
    rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
    rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;

    // Calculate vertical offset for alignment: positions 0-3 up 2px, positions 4-7 up 1px
    bool is_second_row = (disp->y >= 32);
    int y_offset = is_second_row ? -1 : -2;  // Move up 1px for second row, 2px for first row

    disp->box_object_id = object_table->registerEntry();
    disp->value_object_id = object_table->registerEntry();
    disp->label_object_id = object_table->registerEntry();
    disp->value_text_id = text_table->registerEntry();
    disp->label_text_id = text_table->registerEntry();

    // Box object: Rectangle around the numeric value only (Elektron style) - extended down 2px
    object_table->array[disp->box_object_id][object_table->FIELD_TYPE] = 1;
    object_table->array[disp->box_object_id][object_table->FIELD_X] = disp->x;
    object_table->array[disp->box_object_id][object_table->FIELD_Y] = disp->y + y_offset;
    object_table->array[disp->box_object_id][object_table->FIELD_W] = disp->width;
    object_table->array[disp->box_object_id][object_table->FIELD_H] = disp->height - 8; // Extended down by 2px (was -10)
    object_table->array[disp->box_object_id][object_table->FIELD_COLOR] = 0;
    object_table->array[disp->box_object_id][object_table->FIELD_SCALE] = 1;
    object_table->array[disp->box_object_id][object_table->FIELD_TEXT_ID] = 0;
    object_table->array[disp->box_object_id][object_table->FIELD_PAGE] = disp->page;

    // Value object: Numeric value text inside the rectangle (centered)
    object_table->array[disp->value_object_id][object_table->FIELD_TYPE] = 9; // Centered text
    object_table->array[disp->value_object_id][object_table->FIELD_X] = disp->x;
    object_table->array[disp->value_object_id][object_table->FIELD_Y] = disp->y + y_offset;
    object_table->array[disp->value_object_id][object_table->FIELD_W] = disp->width;
    object_table->array[disp->value_object_id][object_table->FIELD_H] = disp->height - 8; // Same height as rectangle
    object_table->array[disp->value_object_id][object_table->FIELD_COLOR] = 2;
    object_table->array[disp->value_object_id][object_table->FIELD_SCALE] = 1;
    object_table->array[disp->value_object_id][object_table->FIELD_TEXT_ID] = disp->value_text_id;
    object_table->array[disp->value_object_id][object_table->FIELD_PAGE] = disp->page;

    // Label object: Text below moved down 2px more (Elektron style)
    object_table->array[disp->label_object_id][object_table->FIELD_TYPE] = 9;
    object_table->array[disp->label_object_id][object_table->FIELD_X] = disp->x;
    object_table->array[disp->label_object_id][object_table->FIELD_Y] = disp->y + y_offset + disp->height - 7; // Moved down 2px (was -9)
    object_table->array[disp->label_object_id][object_table->FIELD_W] = disp->width;
    object_table->array[disp->label_object_id][object_table->FIELD_H] = 8; // Text height
    object_table->array[disp->label_object_id][object_table->FIELD_COLOR] = 2;
    object_table->array[disp->label_object_id][object_table->FIELD_SCALE] = 1;
    object_table->array[disp->label_object_id][object_table->FIELD_TEXT_ID] = disp->label_text_id;
    object_table->array[disp->label_object_id][object_table->FIELD_PAGE] = disp->page;

    // Set initial label text (just the label, not the value)
    strcpy(text_table->array[disp->label_text_id], disp->label);
    disp->last_value = 0xFFFFFFFF;
}

void intdisplay_update(intdisplay_t* disp) __attribute__ ((noinline)) {
    rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
    rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;

    int32_t value = param_table->array[disp->page][disp->param];
    if (value == disp->last_value) {
        return;
    }
    disp->last_value = value;

    // Put numeric value in the value text field (inside rectangle) 
    char value_str[12] = "";
    text_table->itoa(value_str, value);
    strcpy(text_table->array[disp->value_text_id], value_str);
    
    // Keep the label text separate (already set in init, no need to update unless it changes)
}

// ======================== VIRTUAL KNOB FUNCTIONALITY ========================

// Complete circle coordinates - gap at BOTTOM for labels
const int8_t circle_coords[44][2] = {
    // Starting from top (270Â°) going clockwise, skipping bottom gap
    { 0, -8}, { 1, -8}, { 2, -8}, { 3, -7}, { 4, -7}, { 5, -6}, { 6, -5}, { 7, -4}, // Top to right
    { 7, -3}, { 8, -2}, { 8, -1}, { 8,  0}, { 8,  1}, { 8,  2}, { 7,  3}, { 7,  4}, // Right side
    { 6,  5}, { 5,  6}, { 4,  7}, { 3,  7},                                          // Right to bottom (stop before gap)
    // BOTTOM GAP HERE for labels - skip: { 2,  8}, { 1,  8}, { 0,  8}, {-1,  8}, {-2,  8}
    {-3,  7}, {-4,  7}, {-5,  6}, {-6,  5}, {-7,  4}, {-7,  3}, {-8,  2}, {-8,  1}, // Bottom to left (after gap)
    {-8,  0}, {-8, -1}, {-8, -2}, {-7, -3}, {-7, -4}, {-6, -5}, {-5, -6}, {-4, -7}, // Left side
    {-3, -7}, {-2, -8}, {-1, -8}                                                     // Left to top
};

// Updated coordinates from your new list with center at I9
const int8_t indicator_coords[31][2] = {
    {-5,  5},  // 0: Position 1 (D14) = D14 - I9 = (-5, +5)
    {-6,  4},  // 1: Position 2 (C13) = C13 - I9 = (-6, +4)
    {-6,  3},  // 2: Position 3 (C12) = C12 - I9 = (-6, +3)
    {-7,  2},  // 3: Position 4 (B11) = B11 - I9 = (-7, +2)
    {-7,  1},  // 4: Position 5 (B10) = B10 - I9 = (-7, +1)
    {-7,  0},  // 5: Position 6 (B9)  = B9  - I9 = (-7,  0)
    {-7, -1},  // 6: Position 7 (B8)  = B8  - I9 = (-7, -1)
    {-7, -2},  // 7: Position 8 (B7)  = B7  - I9 = (-7, -2)
    {-6, -3},  // 8: Position 9 (C6)  = C6  - I9 = (-6, -3)
    {-6, -4},  // 9: Position 10 (C5) = C5  - I9 = (-6, -4)
    {-5, -5},  //10: Position 11 (D4) = D4  - I9 = (-5, -5)
    {-4, -6},  //11: Position 12 (E3) = E3  - I9 = (-4, -6)
    {-3, -6},  //12: Position 13 (F3) = F3  - I9 = (-3, -6)
    {-2, -7},  //13: Position 14 (G2) = G2  - I9 = (-2, -7)
    {-1, -7},  //14: Position 15 (H2) = H2  - I9 = (-1, -7)
    { 0, -7},  //15: Position 16 (I2) = I2  - I9 = ( 0, -7)
    { 1, -7},  //16: Position 17 (J2) = J2  - I9 = (+1, -7)
    { 2, -7},  //17: Position 18 (K2) = K2  - I9 = (+2, -7)
    { 3, -6},  //18: Position 19 (L3) = L3  - I9 = (+3, -6)
    { 4, -6},  //19: Position 20 (M3) = M3  - I9 = (+4, -6)
    { 5, -5},  //20: Position 21 (N4) = N4  - I9 = (+5, -5)
    { 6, -4},  //21: Position 22 (O5) = O5  - I9 = (+6, -4)
    { 6, -3},  //22: Position 23 (O6) = O6  - I9 = (+6, -3)
    { 7, -2},  //23: Position 24 (P7) = P7  - I9 = (+7, -2)
    { 7, -1},  //24: Position 25 (P8) = P8  - I9 = (+7, -1)
    { 7,  0},  //25: Position 26 (P9) = P9  - I9 = (+7,  0)
    { 7,  1},  //26: Position 27 (P10)= P10 - I9 = (+7, +1)
    { 7,  2},  //27: Position 28 (P11)= P11 - I9 = (+7, +2)
    { 6,  3},  //28: Position 29 (O12)= O12 - I9 = (+6, +3)
    { 6,  4},  //29: Position 30 (O13)= O13 - I9 = (+6, +4)
    { 5,  5},  //30: Position 31 (N14)= N14 - I9 = (+5, +5)
};



// Draw indicator line from center to exact position using lookup table
void draw_indicator_line(int cx, int cy, int indicator_index) __attribute__ ((noinline)) {
    if (indicator_index < 0 || indicator_index >= INDICATOR_POSITIONS) return;
    
    // Get exact end position from lookup table
    int end_x = cx + indicator_coords[indicator_index][0];
    int end_y = cy + indicator_coords[indicator_index][1];
    
    // Draw line from center to exact position (NO TRIGONOMETRY!)
    draw_line(cx, cy, end_x, end_y, 0, 1);  // Use original draw_line function
}

// Draw bipolar indicators (- and + at circle edges)
void draw_bipolar_indicators(int cx, int cy) __attribute__ ((noinline)) {
    // Draw "-" on the left side
    int minus_x = cx - 9;
    int minus_y = cy + 6;
    draw_line(minus_x - 1, minus_y, minus_x + 1, minus_y, 0, 1);  // Horizontal line for "-"
    
    // Draw "+" on the right side
    int plus_x = cx + 9;
    int plus_y = cy + 6;
    draw_line(plus_x - 1, plus_y, plus_x + 1, plus_y, 0, 1);     // Horizontal line
    draw_line(plus_x, plus_y - 1, plus_x, plus_y + 1, 0, 1);     // Vertical line for "+"
}

// NEW DIAL FUNCTIONALITY: Virtual knobs with round indicators
typedef struct {
    uint16_t box_object_id;
    uint16_t label_object_id;
    uint16_t label_text_id;
    int32_t last_value;
    int32_t page;
    int32_t param;
    bool is_bipolar;
    int32_t x;
    int32_t y;
    int32_t width;
    int32_t height;
    const char* label;
    bool show_value;
    int32_t default_value;
} dial_t;

void dial_init(dial_t* dial) __attribute__ ((noinline)) { 
    // Get table pointers
    rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
    rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;

    // Register and get ids
    dial->box_object_id = object_table->registerEntry();
    dial->label_object_id = object_table->registerEntry();
    dial->label_text_id = text_table->registerEntry();

    // Detect if this is a second row dial (dials 4-7 typically have Y >= 32)
    bool is_second_row = (dial->y >= 32);
    int y_offset = is_second_row ? 1 : 0;  // Move second row down by 1 pixel

    // Setup box object for storing dial data
    object_table->array[dial->box_object_id][object_table->FIELD_TYPE] = 2;  // Will be overridden in update
    object_table->array[dial->box_object_id][object_table->FIELD_X] = dial->x;
    object_table->array[dial->box_object_id][object_table->FIELD_Y] = dial->y + y_offset;
    object_table->array[dial->box_object_id][object_table->FIELD_W] = dial->width;
    object_table->array[dial->box_object_id][object_table->FIELD_H] = 0;
    object_table->array[dial->box_object_id][object_table->FIELD_COLOR] = 0;
    object_table->array[dial->box_object_id][object_table->FIELD_SCALE] = 1;
    object_table->array[dial->box_object_id][object_table->FIELD_TEXT_ID] = 0;
    object_table->array[dial->box_object_id][object_table->FIELD_PAGE] = dial->page;

    // Setup label object - positioned for text below knob
    object_table->array[dial->label_object_id][object_table->FIELD_TYPE] = 9;
    object_table->array[dial->label_object_id][object_table->FIELD_X] = dial->x;
    object_table->array[dial->label_object_id][object_table->FIELD_Y] = dial->y + y_offset + dial->height - 9;
    object_table->array[dial->label_object_id][object_table->FIELD_W] = dial->width;
    object_table->array[dial->label_object_id][object_table->FIELD_H] = 8;
    object_table->array[dial->label_object_id][object_table->FIELD_COLOR] = 2;
    object_table->array[dial->label_object_id][object_table->FIELD_SCALE] = 1;
    object_table->array[dial->label_object_id][object_table->FIELD_TEXT_ID] = dial->label_text_id;
    object_table->array[dial->label_object_id][object_table->FIELD_PAGE] = dial->page;

    // Setup label text
    strcpy(text_table->array[dial->label_text_id], dial->label);
    
    // Set default value and initialize change detection
    param_table->array[dial->page][dial->param] = dial->default_value;
    dial->last_value = -999999;  // Force first update
}

void dial_update(dial_t* dial) __attribute__ ((noinline)) {
    // Get table pointers 
    rootc::instancesketchy__objects* object_table = &parent->instancesketchy__objects_i;
    rootc::instancesketchy__texts* text_table = &parent->instancesketchy__texts_i;
    rootc::instancesketchy__params* param_table = &parent->instancesketchy__params_i;

    int32_t value = param_table->array[dial->page][dial->param];

    // Abort if value is the same (change detection for performance)
    if (value == dial->last_value) {
        return;
    }

    dial->last_value = value;

    // Calculate dial center (accounting for second row offset)
    bool is_second_row = (dial->y >= 32);
    int y_offset = is_second_row ? 1 : 0;
    int cx = dial->x + dial->width/2;
    int cy = dial->y + y_offset + dial->height/2 - 6;
    
    // Process value differently for bipolar vs unipolar
    float lookup_pos;
    
    if (dial->is_bipolar) {
        // Bipolar: transform value and map to -1/+1 range, then convert to 0/1 for lookup
        value = (value-(1<<26))<<1;
        float frac_value = ((float)value / 0x00200000);
        float norm_value = frac_value / 64.0f;
        
        // Clamp to -1.0 to 1.0 range
        if (norm_value < -1.0f) norm_value = -1.0f;
        if (norm_value > 1.0f) norm_value = 1.0f;
        
        // Convert from -1/+1 to 0/1 range for lookup
        lookup_pos = (norm_value + 1.0f) / 2.0f;
    } else {
        // Unipolar: map 0 to max_value directly to 0/1 range for full circle coverage
        float max_value = (1<<27);  // 134217728
        lookup_pos = (float)value / max_value;
        
        // Clamp to 0.0 to 1.0 range
        if (lookup_pos < 0.0f) lookup_pos = 0.0f;
        if (lookup_pos > 1.0f) lookup_pos = 1.0f;
    }
    
    // Map to indicator positions
    int indicator_index = (int)(lookup_pos * (INDICATOR_POSITIONS - 1) + 0.5f);
    if (indicator_index < 0) indicator_index = 0;
    if (indicator_index >= INDICATOR_POSITIONS) indicator_index = INDICATOR_POSITIONS - 1;
    
    // Store knob data in object table for rendering
    // Type 99 = regular knob, Type 100 = bipolar knob with +/- indicators
    int knob_type = dial->is_bipolar ? 100 : 99;
    object_table->array[dial->box_object_id][object_table->FIELD_TYPE] = knob_type;
    object_table->array[dial->box_object_id][object_table->FIELD_X] = cx;    // Center X
    object_table->array[dial->box_object_id][object_table->FIELD_Y] = cy;    // Center Y
    object_table->array[dial->box_object_id][object_table->FIELD_W] = indicator_index; // Store indicator position
    object_table->array[dial->box_object_id][object_table->FIELD_H] = dial->width;     // Store dial width for bounds

    // Update label text
    strcpy(text_table->array[dial->label_text_id], dial->label);
}]]></code.declaration>
      <code.init><![CDATA[object_table = &parent->instancesketchy__objects_i;
text_table = &parent->instancesketchy__texts_i;
param_table = &parent->instancesketchy__params_i;
font = &parent->instancesketchy__font_i;

palSetPadMode(GPIOB, 8, PAL_MODE_ALTERNATE(4)|PAL_STM32_PUDR_PULLUP|PAL_STM32_OTYPE_OPENDRAIN);
palSetPadMode(GPIOB, 9, PAL_MODE_ALTERNATE(4)|PAL_STM32_PUDR_PULLUP|PAL_STM32_OTYPE_OPENDRAIN);
static const I2CConfig i2cfg = {
    OPMODE_I2C,
    400000,
    FAST_DUTY_CYCLE_2,
};
i2cStart(&I2CD1, &i2cfg);
Thd = chThdCreateStatic(waThreadX, sizeof(waThreadX), NORMALPRIO, ThreadX, (void *)this);

clear();

pprint = false;
page = 0;
layout = 0xFFFF;]]></code.init>
      <code.dispose><![CDATA[chThdTerminate( Thd );
chThdWait( Thd );
i2cStop(&I2CD1);
palSetPadMode(GPIOB, 8, PAL_MODE_INPUT_ANALOG);
palSetPadMode(GPIOB, 9, PAL_MODE_INPUT_ANALOG);]]></code.dispose>
      <code.krate><![CDATA[if (inlet_print && !pprint) {
  pprint = true;
  for (uint8_t i = 0; i < parent->instancesketchy__objects_i.LENGTH; i++) {
    LogTextMessage(
      "i: %3d, type: %3d, x: %3d, y: %3d, w: %3d, h: %3d, color: %3d, text_id: %3d",
      i,
      parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TYPE],
      parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_X], 
      parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_Y], 
      parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_W],
      parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_H], 
      parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_COLOR],
      parent->instancesketchy__objects_i.array[i][parent->instancesketchy__objects_i.FIELD_TEXT_ID]
    );
  }
  LogTextMessage("");
}

if (!inlet_print && pprint) {
  pprint = false;
}

if (page != inlet_page) {
	page = inlet_page;
}
if (layout != inlet_layout) {
	layout = inlet_layout;
}

outlet_sw = LCDWIDTH;
outlet_sh = LCDHEIGHT;]]></code.krate>
   </obj.normal>
</objdefs>
