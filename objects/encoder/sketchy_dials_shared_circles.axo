<objdefs appVersion="1.0.12">
   <obj.normal id="sketchy_dials_shared_circles" uuid="8e42a9f1-5c67-4d2a-9f38-2b8e9d4c7e12">
      <sDescription>Complete dial configuration optimized for shared circle renderer. Uses 88% fewer circle objects while maintaining full functionality including all modes, display types, and configuration data.</sDescription>
      <author>AI Assistant</author>
      <license>MIT</license>
      <inlets>
         <int32 name="page"/>
      </inlets>
      <outlets/>
      <displays/>
      <params/>
      <attribs/>
      <depends>
         <depend>sketchy_font</depend>
         <depend>sketchy_params</depend>
         <depend>sketchy_objects</depend>
         <depend>sketchy_texts</depend>
         <depend>sketchy_render</depend>
      </depends>
      <code.declaration><![CDATA[// Complete dial configuration structure - matches original functionality
typedef struct {
    uint8_t mode;           // 0=frac unipolar, 1=frac bipolar, 2=int, 3=list, 4=bar unipolar, 5=bar bipolar, 6=duplicate
    bool show_value;        // Show/hide value (for fractional modes)
    const char* label;      // Label text
    const char* options;    // List options (for mode 3) OR duplicate reference "page,dial" (for mode 6)
    float default_value;    // Default value
    int16_t int_min;        // Minimum value (for int/list modes)
    int16_t int_max;        // Maximum value (for int/list modes)
} encoder_dial_config_t;

// Configuration for 8 pages, 8 encoders each (64 total configurations)
// Making this public so other objects can access it via parent->instancesketchy__dials_i.configs
encoder_dial_config_t configs[8][8];

// Mode constants
#define MODE_FRAC_UNIPOLAR 0  // 0.0 to 1.0, positive only
#define MODE_FRAC_BIPOLAR  1  // -1.0 to 1.0, bipolar
#define MODE_INT           2  // min to max, integer
#define MODE_LIST          3  // selector mode
#define MODE_BAR_UNIPOLAR  4  // 0.0 to 1.0, vertical bar
#define MODE_BAR_BIPOLAR   5  // -1.0 to 1.0, vertical bar
#define MODE_DUPLICATE     6  // duplicate another parameter

// Display structures for each type - 64 total (8 pages x 8 dials)
// Using the renderer's type definitions for compatibility
rootc::instancesketchy__render::dial_t dials[64];
rootc::instancesketchy__render::intdisplay_t intdisplays[64];
rootc::instancesketchy__render::select_t selects[64];
rootc::instancesketchy__render::bar_t bars[64];

// Fixed layout positions
const uint8_t DIAL_WIDTH = 24;
const uint8_t DIAL_HEIGHT = 24;
const uint8_t ROW1_Y = 13;
const uint8_t ROW2_Y = 39;
const uint8_t COL_X[4] = {26, 52, 78, 104};

// Initialize complete configuration data - matches original functionality
void init_config_data() {
    // PAGE 0 - Oscillator controls
    configs[0][0] = (encoder_dial_config_t){1, true,  "FIN", "", 0.0f, 0, 127};
    configs[0][1] = (encoder_dial_config_t){1, true,  "WAV", "", 32.0f, 0, 127};
    configs[0][2] = (encoder_dial_config_t){3, false, "SEL", "Sin,Tri,Saw,Sqr,Nse", 2.0f, 0, 4};
    configs[0][3] = (encoder_dial_config_t){5, true,  "DOT", "", 32.0f, 0, 127};
    configs[0][4] = (encoder_dial_config_t){0, false, "DET", "", 0.0f, 0, 127};
    configs[0][5] = (encoder_dial_config_t){0, false, "SUB", "", 0.0f, 0, 127};
    configs[0][6] = (encoder_dial_config_t){2, false, "OCT", "", 0.0f, -4, 4};
    configs[0][7] = (encoder_dial_config_t){4, false, "DOWN", "", 0.0f, 0, 127};

    // PAGE 1 - Filter controls
    configs[1][0] = (encoder_dial_config_t){0, true,  "CUT", "", 32.0f, 0, 127};
    configs[1][1] = (encoder_dial_config_t){1, true,  "RES", "", 0.0f, 0, 127};
    configs[1][2] = (encoder_dial_config_t){1, false, "ENV", "", 0.0f, -64, 64};
    configs[1][3] = (encoder_dial_config_t){3, false, "TYP", "LP,HP,BP,BR", 0.0f, 0, 3};
    configs[1][4] = (encoder_dial_config_t){0, false, "KBD", "", 16.0f, 0, 127};
    configs[1][5] = (encoder_dial_config_t){0, false, "VEL", "", 0.0f, 0, 127};
    configs[1][6] = (encoder_dial_config_t){0, false, "LFO", "", 0.0f, 0, 127};
    configs[1][7] = (encoder_dial_config_t){2, false, "DRV", "", 8.0f, 0, 100};

    // PAGE 2 - Envelope controls
    configs[2][0] = (encoder_dial_config_t){0, false, "ATK", "", 8.0f, 0, 127};
    configs[2][1] = (encoder_dial_config_t){0, false, "DEC", "", 16.0f, 0, 127};
    configs[2][2] = (encoder_dial_config_t){0, false, "SUS", "", 48.0f, 0, 127};
    configs[2][3] = (encoder_dial_config_t){0, false, "REL", "", 24.0f, 0, 127};
    configs[2][4] = (encoder_dial_config_t){1, false, "VEL", "", 0.0f, -100, 100};
    configs[2][5] = (encoder_dial_config_t){1, false, "CRV", "", 0.0f, -50, 50};
    configs[2][6] = (encoder_dial_config_t){0, false, "TIM", "", 32.0f, 0, 127};
    configs[2][7] = (encoder_dial_config_t){3, false, "TYP", "Lin,Exp,Log", 1.0f, 0, 2};

    // PAGE 3 - LFO controls
    configs[3][0] = (encoder_dial_config_t){0, true,  "RAT", "", 16.0f, 0, 127};
    configs[3][1] = (encoder_dial_config_t){1, false, "DEP", "", 0.0f, -127, 127};
    configs[3][2] = (encoder_dial_config_t){1, false, "PHS", "", 0.0f, -127, 127};
    configs[3][3] = (encoder_dial_config_t){3, false, "SHP", "Sin,Tri,Saw,Sqr,S&H", 1.0f, 0, 4};
    configs[3][4] = (encoder_dial_config_t){0, false, "SYN", "", 0.0f, 0, 127};
    configs[3][5] = (encoder_dial_config_t){0, false, "DEL", "", 0.0f, 0, 127};
    configs[3][6] = (encoder_dial_config_t){0, false, "FAD", "", 0.0f, 0, 127};
    configs[3][7] = (encoder_dial_config_t){2, false, "DIV", "", 8.0f, 1, 32};

    // PAGE 4 - Effects controls
    configs[4][0] = (encoder_dial_config_t){0, false, "REV", "", 16.0f, 0, 127};
    configs[4][1] = (encoder_dial_config_t){0, false, "DEL", "", 0.0f, 0, 127};
    configs[4][2] = (encoder_dial_config_t){0, false, "CHO", "", 0.0f, 0, 127};
    configs[4][3] = (encoder_dial_config_t){0, false, "DIS", "", 0.0f, 0, 127};
    configs[4][4] = (encoder_dial_config_t){1, false, "TIM", "", 0.0f, -64, 64};
    configs[4][5] = (encoder_dial_config_t){1, false, "FBK", "", 0.0f, -100, 100};
    configs[4][6] = (encoder_dial_config_t){0, false, "MIX", "", 32.0f, 0, 127};
    configs[4][7] = (encoder_dial_config_t){3, false, "TYP", "Off,Hall,Room,Plate", 2.0f, 0, 3};

    // PAGE 5 - Sequencer controls
    configs[5][0] = (encoder_dial_config_t){2, true,  "STP", "", 8.0f, 1, 64};
    configs[5][1] = (encoder_dial_config_t){0, true,  "SPD", "", 32.0f, 0, 127};
    configs[5][2] = (encoder_dial_config_t){1, false, "SWG", "", 0.0f, -50, 50};
    configs[5][3] = (encoder_dial_config_t){3, false, "DIR", "Fwd,Rev,P-P,Rnd", 0.0f, 0, 3};
    configs[5][4] = (encoder_dial_config_t){0, false, "GAT", "", 48.0f, 0, 127};
    configs[5][5] = (encoder_dial_config_t){1, false, "ACC", "", 0.0f, -127, 127};
    configs[5][6] = (encoder_dial_config_t){0, false, "SLD", "", 0.0f, 0, 127};
    configs[5][7] = (encoder_dial_config_t){2, false, "RST", "", 0.0f, 0, 1};

    // PAGE 6 - Modulation controls
    configs[6][0] = (encoder_dial_config_t){1, false, "M1A", "", 0.0f, -127, 127};
    configs[6][1] = (encoder_dial_config_t){1, false, "M2A", "", 0.0f, -127, 127};
    configs[6][2] = (encoder_dial_config_t){1, false, "M3A", "", 0.0f, -127, 127};
    configs[6][3] = (encoder_dial_config_t){3, false, "SRC", "LFO,ENV,VEL,RND", 0.0f, 0, 3};
    configs[6][4] = (encoder_dial_config_t){3, false, "DS1", "Cut,Res,Amp,Pan", 0.0f, 0, 3};
    configs[6][5] = (encoder_dial_config_t){3, false, "DS2", "Pit,Phs,PWM,FM", 0.0f, 0, 3};
    configs[6][6] = (encoder_dial_config_t){0, false, "ATN", "", 64.0f, 0, 127};
    configs[6][7] = (encoder_dial_config_t){2, false, "LAG", "", 0.0f, 0, 100};

    // PAGE 7 - Global controls
    configs[7][0] = (encoder_dial_config_t){0, true,  "VOL", "", 48.0f, 0, 127};
    configs[7][1] = (encoder_dial_config_t){1, false, "PAN", "", 0.0f, -64, 64};
    configs[7][2] = (encoder_dial_config_t){0, false, "TUN", "", 32.0f, 0, 127};
    configs[7][3] = (encoder_dial_config_t){2, true,  "TRS", "", 0.0f, -24, 24};
    configs[7][4] = (encoder_dial_config_t){0, false, "VEL", "", 48.0f, 0, 127};
    configs[7][5] = (encoder_dial_config_t){0, false, "POR", "", 0.0f, 0, 127};
    configs[7][6] = (encoder_dial_config_t){2, false, "CHN", "", 1.0f, 1, 16};
    configs[7][7] = (encoder_dial_config_t){3, false, "PLY", "Poly,Mono,Leg", 0.0f, 0, 2};
}

// Convert from display value to encoder position (0-1)
float displayToEncoderValue(float displayValue, int mode) {
    switch(mode) {
        case MODE_FRAC_UNIPOLAR:
        case MODE_BAR_UNIPOLAR:
            // 0-64 display maps to 0-1 encoder
            return displayValue / 64.0f;
        case MODE_FRAC_BIPOLAR:
        case MODE_BAR_BIPOLAR:
            // -64 to +64 display maps to 0-1 encoder (-64 = 0.0, 0 = 0.5, +64 = 1.0)
            return (displayValue + 64.0f) / 128.0f;
        case MODE_INT:
        case MODE_LIST:
            // Not used for these modes
            return 0.0f;
        default:
            return displayValue;
    }
}

// Parse duplicate reference "page,dial" into page and dial indices
void parse_duplicate_reference(const char* options, uint8_t* ref_page, uint8_t* ref_dial) {
    *ref_page = 0;
    *ref_dial = 0;
    
    // Simple parsing: expect "page,dial" format
    if (options && strlen(options) >= 3) {
        *ref_page = options[0] - '0';  // Convert first char to number
        if (options[1] == ',' && options[2] >= '0' && options[2] <= '7') {
            *ref_dial = options[2] - '0';  // Convert third char to number
        }
    }
}

// Initialize a single dial based on its configuration
void init_dial(uint8_t page, uint8_t dial_index, const encoder_dial_config_t* config) {
    uint8_t array_index = page * 8 + dial_index;
    float encoder_pos;  // Declare variable outside switch
    
    switch (config->mode) {
        case MODE_FRAC_UNIPOLAR:
        case MODE_FRAC_BIPOLAR:
            dials[array_index].page = page;
            dials[array_index].param = dial_index;
            dials[array_index].is_bipolar = (config->mode == MODE_FRAC_BIPOLAR);
            dials[array_index].x = COL_X[dial_index % 4];
            dials[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            dials[array_index].width = DIAL_WIDTH;
            dials[array_index].height = DIAL_HEIGHT;
            dials[array_index].label = config->label;
            dials[array_index].show_value = config->show_value;
            // Convert config default to encoder position (0-1), then to display format for renderer
            encoder_pos = displayToEncoderValue(config->default_value, config->mode);
            if (encoder_pos < 0.0f) encoder_pos = 0.0f;
            if (encoder_pos > 1.0f) encoder_pos = 1.0f;
            dials[array_index].default_value = (int32_t)(encoder_pos * (float)(1 << 27));
            parent->instancesketchy__render_i.dial_init(&dials[array_index]);
            break;
            
        case MODE_BAR_UNIPOLAR:
        case MODE_BAR_BIPOLAR:
            bars[array_index].page = page;
            bars[array_index].param = dial_index;
            bars[array_index].is_bipolar = (config->mode == MODE_BAR_BIPOLAR);
            bars[array_index].x = COL_X[dial_index % 4];
            bars[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            bars[array_index].width = DIAL_WIDTH;
            bars[array_index].height = DIAL_HEIGHT;
            bars[array_index].label = config->label;
            bars[array_index].show_value = config->show_value;
            encoder_pos = displayToEncoderValue(config->default_value, config->mode);
            if (encoder_pos < 0.0f) encoder_pos = 0.0f;
            if (encoder_pos > 1.0f) encoder_pos = 1.0f;
            bars[array_index].default_value = (int32_t)(encoder_pos * (float)(1 << 27));
            parent->instancesketchy__render_i.bar_init(&bars[array_index]);
            break;
            
        case MODE_INT:
            intdisplays[array_index].page = page;
            intdisplays[array_index].param = dial_index;
            intdisplays[array_index].x = COL_X[dial_index % 4];
            intdisplays[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            intdisplays[array_index].width = DIAL_WIDTH;
            intdisplays[array_index].height = DIAL_HEIGHT;
            intdisplays[array_index].label = config->label;
            intdisplays[array_index].show_value = config->show_value;
            intdisplays[array_index].min_value = config->int_min;
            intdisplays[array_index].max_value = config->int_max;
            intdisplays[array_index].default_value = (int32_t)config->default_value;
            parent->instancesketchy__render_i.intdisplay_init(&intdisplays[array_index]);
            break;
            
        case MODE_LIST:
            selects[array_index].page = page;
            selects[array_index].param = dial_index;
            selects[array_index].x = COL_X[dial_index % 4];
            selects[array_index].y = (dial_index < 4) ? ROW1_Y : ROW2_Y;
            selects[array_index].width = DIAL_WIDTH;
            selects[array_index].height = DIAL_HEIGHT;
            selects[array_index].label = config->label;
            selects[array_index].show_value = config->show_value;
            selects[array_index].options = config->options;
            selects[array_index].min_value = config->int_min;
            selects[array_index].max_value = config->int_max;
            selects[array_index].default_value = (int32_t)config->default_value;
            parent->instancesketchy__render_i.select_init(&selects[array_index]);
            break;
            
        case MODE_DUPLICATE:
            // For duplicate mode, we still need to initialize a display
            // Use the same type as the referenced parameter
            uint8_t ref_page, ref_dial;
            parse_duplicate_reference(config->options, &ref_page, &ref_dial);
            if (ref_page < 8 && ref_dial < 8) {
                // Initialize based on the referenced parameter's type
                init_dial(page, dial_index, &configs[ref_page][ref_dial]);
            }
            break;
    }
}]]></code.declaration>
      <code.init><![CDATA[init_config_data();

// Initialize all dials for all pages
for (uint8_t page = 0; page < 8; page++) {
    for (uint8_t dial = 0; dial < 8; dial++) {
        init_dial(page, dial, &configs[page][dial]);
    }
}]]></code.init>
      <code.dispose><![CDATA[// Clean up handled by renderer]]></code.dispose>
      <code.krate><![CDATA[// Update dials for current page
for (int i = 0; i < 8; i++) {
    uint8_t array_index = inlet_page * 8 + i;
    auto& config = configs[inlet_page][i];
    
    switch (config.mode) {
        case MODE_FRAC_UNIPOLAR:
        case MODE_FRAC_BIPOLAR:
            parent->instancesketchy__render_i.dial_update(&dials[array_index]);
            break;
        case MODE_BAR_UNIPOLAR:
        case MODE_BAR_BIPOLAR:
            parent->instancesketchy__render_i.bar_update(&bars[array_index]);
            break;
        case MODE_INT:
            parent->instancesketchy__render_i.intdisplay_update(&intdisplays[array_index]);
            break;
        case MODE_LIST:
            parent->instancesketchy__render_i.select_update(&selects[array_index]);
            break;
        case MODE_DUPLICATE:
            // For duplicate mode, update based on the referenced parameter's type
            uint8_t ref_page, ref_dial;
            parse_duplicate_reference(config.options, &ref_page, &ref_dial);
            if (ref_page < 8 && ref_dial < 8) {
                auto& ref_config = configs[ref_page][ref_dial];
                switch (ref_config.mode) {
                    case MODE_FRAC_UNIPOLAR:
                    case MODE_FRAC_BIPOLAR:
                        parent->instancesketchy__render_i.dial_update(&dials[array_index]);
                        break;
                    case MODE_BAR_UNIPOLAR:
                    case MODE_BAR_BIPOLAR:
                        parent->instancesketchy__render_i.bar_update(&bars[array_index]);
                        break;
                    case MODE_INT:
                        parent->instancesketchy__render_i.intdisplay_update(&intdisplays[array_index]);
                        break;
                    case MODE_LIST:
                        parent->instancesketchy__render_i.select_update(&selects[array_index]);
                        break;
                }
            }
            break;
    }
}]]></code.krate>
   </obj.normal>
</objdefs> 